<!DOCTYPE html>
<html lang="de" class="h-full bg-slate-950">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#020617" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="CompNavAir" />
  <title>CompNavAir</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet Omnivore (KML import) -->
  <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

  <!-- FontAwesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; }
    .no-select { user-select: none; -webkit-user-select: none; }
    .safe-bottom { padding-bottom: calc(env(safe-area-inset-bottom) + 0px); }
    .safe-top { padding-top: env(safe-area-inset-top); }
    #map { height: 100%; width: 100%; }
    .leaflet-container { background: #0b1220; }
    .btn-touch { touch-action: manipulation; }
    .shadow-soft { box-shadow: 0 12px 30px rgba(0,0,0,.35); }
    .panel-scroll { max-height: calc(100vh - 7.5rem); overflow: auto; -webkit-overflow-scrolling: touch; }
    .mono { font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1; }
    .balloon-icon { width: 28px; height: 28px; display: grid; place-items: center; }
    .balloon-rot { width: 28px; height: 28px; display: grid; place-items: center; transform-origin: 50% 50%; }
    .leaflet-control-container { z-index: 10; }
  </style>
</head>

<body class="h-full text-slate-100">
  <div id="app" class="h-full w-full flex flex-col bg-slate-950">
    <!-- Header -->
    <header class="safe-top z-40 bg-slate-950/90 backdrop-blur border-b border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex items-center gap-2 min-w-0">
          <div class="w-9 h-9 rounded-2xl bg-slate-900 border border-slate-800 grid place-items-center">
            <i class="fa-solid fa-balloon text-sky-300"></i>
          </div>
          <div class="min-w-0">
            <div class="font-extrabold leading-5 truncate">CompNavAir</div>
            <div class="text-xs text-slate-400 leading-4 truncate">
              <span id="gpsBadge" class="inline-flex items-center gap-1">
                <span id="gpsDot" class="w-2 h-2 rounded-full bg-slate-500 inline-block"></span>
                <span id="gpsText">GPS: –</span>
              </span>
              <span class="mx-2 text-slate-600">•</span>
              <span id="modeText">LIVE</span>
            </div>
          </div>
        </div>

        <div class="ml-auto flex items-center gap-2">
          <button id="btnStartFlight" class="btn-touch h-10 px-3 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-play mr-2"></i>Start
          </button>
          <button id="btnFinish" class="btn-touch hidden h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-flag-checkered mr-2"></i>Fertig
          </button>

          <button id="btnWindHud" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-wind text-slate-200"></i>
          </button>

          <button id="btnMapSettings" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-layer-group text-slate-200"></i>
          </button>

          <button id="btnCenter" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-location-crosshairs text-slate-200"></i>
          </button>

          <button id="btnMenu" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-bars text-slate-200"></i>
          </button>
        </div>
      </div>
    </header>

    <!-- Main -->
    <main class="relative flex-1 min-h-0">
      <div id="map" class="absolute inset-0 z-0"></div>

      <!-- Wind HUD -->
      <div id="windHud" class="hidden absolute left-3 top-3 z-50 w-[86vw] max-w-[360px] rounded-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft">
        <div class="px-3 py-2 flex items-center gap-2 border-b border-slate-800">
          <div class="font-bold"><i class="fa-solid fa-wind mr-2 text-sky-300"></i>Wind HUD</div>
          <div class="ml-auto flex items-center gap-2">
            <button id="btnWindFetch" class="btn-touch px-3 h-9 rounded-xl bg-sky-400 text-slate-950 font-extrabold text-sm hover:bg-sky-300 active:bg-sky-500">
              <i class="fa-solid fa-cloud-arrow-down mr-2"></i>Online
            </button>
            <button id="btnWindClose" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
        </div>
        <div class="px-3 py-2">
          <div class="text-xs text-slate-400 mb-2">Schichten (Höhe / Richtung / Speed). Tippe im Menü auf „Wind“, um manuell zu editieren.</div>
          <div id="windHudList" class="space-y-2"></div>
        </div>
      </div>

      <!-- Nav Toast -->
      <div id="navToast" class="hidden absolute left-1/2 top-3 -translate-x-1/2 z-50 rounded-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft px-4 py-2 max-w-[92vw]">
        <div class="text-sm font-bold truncate">
          <i class="fa-solid fa-route mr-2 text-emerald-300"></i>
          <span id="navTaskName">–</span>
        </div>
        <div class="text-xs text-slate-300 mt-0.5">
          <span class="mono" id="navDist">–</span>
          <span class="mx-2 text-slate-600">•</span>
          <span id="navRec">–</span>
        </div>
      </div>

      <!-- Simulation Controls -->
      <div id="simControls" class="hidden absolute left-3 top-24 z-50 flex flex-col gap-2">
        <button id="btnBurner" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-orange-400 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-fire-flame-curved mr-2"></i>AUF
        </button>
        <button id="btnVent" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-sky-300 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-arrow-down-wide-short mr-2"></i>AB
        </button>
      </div>

      <!-- Map Settings Modal -->
      <div id="mapModal" class="hidden absolute inset-0 z-50">
        <div id="mapModalBg" class="absolute inset-0 bg-black/60"></div>
        <div class="absolute left-1/2 top-24 -translate-x-1/2 w-[92vw] max-w-[420px] rounded-2xl bg-slate-950 border border-slate-800 shadow-soft">
          <div class="px-4 py-3 flex items-center border-b border-slate-800">
            <div class="font-extrabold"><i class="fa-solid fa-layer-group mr-2 text-sky-300"></i>Karte</div>
            <button id="btnMapModalClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
          <div class="p-4 space-y-3">
            <div class="grid grid-cols-2 gap-2">
              <button id="btnBaseOSM" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-map mr-2"></i>OSM
              </button>
              <button id="btnBaseSAT" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-satellite mr-2"></i>Sat
              </button>
            </div>
            <div class="flex items-center justify-between rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">GPS Follow</div>
                <div class="text-xs text-slate-400">Wenn du die Karte ziehst, wird Follow automatisch aus.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglFollow" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglFollowKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>
          </div>
        </div>
      </div>

      <!-- Snackbar -->
      <div id="snackbar" class="hidden absolute left-1/2 bottom-24 -translate-x-1/2 z-50 max-w-[92vw] rounded-2xl bg-slate-950/90 border border-slate-800 shadow-soft px-4 py-2 text-sm"></div>
    </main>

    <!-- Footer Cockpit -->
    <footer class="safe-bottom z-40 bg-slate-950/95 backdrop-blur border-t border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex-1 grid grid-cols-3 gap-2">
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">GS</div>
            <div class="text-lg font-extrabold mono"><span id="instGS">–</span> <span class="text-xs font-bold text-slate-400">km/h</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">ALT</div>
            <div class="text-lg font-extrabold mono"><span id="instALT">–</span> <span class="text-xs font-bold text-slate-400">m</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">VARIO</div>
            <div class="text-lg font-extrabold mono"><span id="instVAR">–</span> <span class="text-xs font-bold text-slate-400">m/s</span></div>
          </div>
        </div>

        <button id="btnMarker" class="btn-touch w-20 h-16 rounded-2xl bg-pink-400 hover:bg-pink-300 active:bg-pink-500 text-slate-950 font-extrabold shadow-soft">
          <i class="fa-solid fa-location-dot mr-2"></i>MARK
        </button>
      </div>
    </footer>
  </div>

  <!-- Side Drawer -->
  <div id="drawerWrap" class="hidden fixed inset-0 z-[60]">
    <div id="drawerBg" class="absolute inset-0 bg-black/60"></div>
    <aside id="drawer" class="absolute right-0 top-0 h-full w-[92vw] max-w-[420px] bg-slate-950 border-l border-slate-800 shadow-soft flex flex-col">
      <div class="safe-top px-4 py-3 flex items-center border-b border-slate-800">
        <div class="font-extrabold"><i class="fa-solid fa-compass mr-2 text-sky-300"></i>Menü</div>
        <button id="btnDrawerClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="px-3 py-2 border-b border-slate-800">
        <div class="grid grid-cols-4 gap-2">
          <button data-tab="task" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Task</button>
          <button data-tab="wind" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Wind</button>
          <button data-tab="setup" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Setup</button>
          <button data-tab="archive" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Archiv</button>
        </div>
      </div>

      <div class="px-4 py-3 panel-scroll">
        <!-- TASK -->
        <section id="tab_task" class="space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-flag mr-2 text-emerald-300"></i>Aktiver Task (Briefing)</div>
            <div class="grid grid-cols-1 gap-2">
              <label class="text-xs text-slate-400">Task-Typ</label>
              <select id="taskType" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 font-bold"></select>

              <label class="text-xs text-slate-400 mt-2">Task-Titel (optional)</label>
              <input id="taskTitle" type="text" placeholder="z.B. Abendfahrt JDG" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
            </div>

            <div id="taskFields" class="mt-3 space-y-3"></div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnApplyTask" class="btn-touch h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-check mr-2"></i>Auf Karte
              </button>
              <button id="btnClearTask" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-trash mr-2"></i>Leeren
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold text-sm mb-2"><i class="fa-solid fa-bullseye mr-2 text-sky-300"></i>Navigation</div>
              <div class="text-xs text-slate-400">Aktiver Task wird im Toast angezeigt (Distanz + Layer-Empfehlung). Fahrt startet **nicht** automatisch.</div>
              <div class="mt-2 grid grid-cols-2 gap-2">
                <button id="btnSetTargetFromMap" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">
                  <i class="fa-solid fa-crosshairs mr-2"></i>Ziel picken
                </button>
                <button id="btnAPTStart" class="btn-touch hidden h-11 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
                  <i class="fa-solid fa-stopwatch mr-2"></i>APT Start
                </button>
              </div>
              <div id="mapPickHint" class="hidden mt-2 text-xs text-amber-300">
                Tippe auf die Karte, um Punkt A zu setzen (Briefing).
              </div>
            </div>
          </div>

          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-diagram-project mr-2 text-sky-300"></i>ELB / ANG Helper</div>
            <div class="text-xs text-slate-400 mb-3">Optional: Trackpunkte während der Fahrt setzen (nur wenn Fahrt aktiv).</div>
            <div class="grid grid-cols-3 gap-2">
              <button id="btnSetA" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set A</button>
              <button id="btnSetB" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set B</button>
              <button id="btnSetC" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set C</button>
            </div>
            <div class="mt-3 text-sm">
              <div class="text-xs text-slate-400">ELB Ergebnis (°):</div>
              <div class="font-extrabold mono text-lg" id="elbowResult">–</div>
            </div>
          </div>
        </section>

        <!-- WIND -->
        <section id="tab_wind" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-wind mr-2 text-sky-300"></i>Windprofil</div>
            <div class="text-xs text-slate-400 mb-3">Manuell editieren oder Online holen. Auto-Record: wenn GS &gt; 10 km/h und ΔH&gt;50 m oder ΔKurs&gt;5° (nur während Fahrt).</div>

            <div class="grid grid-cols-3 gap-2">
              <input id="windAlt" type="number" placeholder="Höhe m" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
              <input id="windDirFrom" type="number" placeholder="Richtung FROM °" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
              <input id="windSpd" type="number" placeholder="Speed km/h" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
            </div>
            <div class="mt-2 grid grid-cols-2 gap-2">
              <button id="btnAddWind" class="btn-touch h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-plus mr-2"></i>Hinzufügen
              </button>
              <button id="btnClearWind" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-trash mr-2"></i>Alle löschen
              </button>
            </div>

            <div class="mt-3 space-y-2" id="windList"></div>
          </div>
        </section>

        <!-- SETUP -->
        <section id="tab_setup" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-gear mr-2 text-sky-300"></i>Setup</div>

            <div class="flex items-center justify-between rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">Simulation</div>
                <div class="text-xs text-slate-400">GPS wird pausiert. Drift basiert auf Windprofil.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglSim" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglSimKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnWakeLock" class="btn-touch h-11 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-mobile-screen mr-2"></i>WakeLock
              </button>
              <button id="btnReset" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-rotate mr-2"></i>Reset UI
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-file-import mr-2 text-emerald-300"></i>KML Import</div>
              <input id="kmlFile" type="file" accept=".kml,.xml" class="block w-full text-sm text-slate-300 file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-bold file:bg-slate-900 file:text-slate-200 hover:file:bg-slate-800" />
              <div class="text-xs text-slate-400 mt-2">Importiertes KML wird als Overlay dargestellt (nur Ansicht).</div>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-download mr-2 text-amber-300"></i>PWA Hinweis</div>
              <div class="text-xs text-slate-400">
                Für „ohne Browser“-Look: im Chrome-Menü „Zum Startbildschirm hinzufügen“ → App öffnen.
              </div>
            </div>
          </div>
        </section>

        <!-- ARCHIVE -->
        <section id="tab_archive" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-box-archive mr-2 text-sky-300"></i>Archiv</div>
            <div class="text-xs text-slate-400 mb-3">Beendete Fahrten + KML Export (Track + Marker).</div>
            <div id="archiveList" class="space-y-2"></div>
            <button id="btnClearArchive" class="btn-touch mt-3 w-full h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
              <i class="fa-solid fa-trash mr-2"></i>Archiv löschen
            </button>
          </div>
        </section>
      </div>
    </aside>
  </div>

  <script>
    /********************************************************************
     * 1) KONSTANTEN & KONFIGURATION
     ********************************************************************/
    const APP = {
      name: "CompNavAir",
      version: "1.0.0",
      defaultCenter: { lat: 49.317, lon: 8.448 }, // Speyer/EDRY Nähe
      defaultZoom: 13,
      storageKey: "compnavair_v1",
      maxTrackPoints: 20000,
      trackMinDistM: 8,
      maxGpsJumpM: 160,            // hartes Jump-Limit
      gpsSmoothingAlpha: 0.25,     // 0..1 (höher = weniger smoothing)
      followPanMinMs: 800,
      kmlName: "CompNavAir_Export",
    };

    const TILE = {
      osm: {
        url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        attr: '&copy; OpenStreetMap-Mitwirkende'
      },
      esri: {
        url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        attr: "Tiles &copy; Esri"
      }
    };

    // CIA Task List (inkl. 15.21 APT) basierend auf AX Model Event Rules (Apr 2025)
    const CIA_TASKS = [
      { num: "15.1",  code: "PDG", title: "SELBST GEWÄHLTES ZIEL" },
      { num: "15.2",  code: "JDG", title: "VORGEGEBENES ZIEL" },
      { num: "15.3",  code: "HWZ", title: "QUAL DER WAHL" },
      { num: "15.4",  code: "FIN", title: "FLY IN" },
      { num: "15.5",  code: "FON", title: "FLY ON" },
      { num: "15.6",  code: "HNH", title: "FUCHSJAGD" },
      { num: "15.7",  code: "WSD", title: "FUCHSJAGD MIT ANLAUF" },
      { num: "15.8",  code: "GBM", title: "GORDON BENNETT MEMORIAL" },
      { num: "15.9",  code: "CRT", title: "ZIELFAHRT MIT ZEITFENSTER" },
      { num: "15.10", code: "RTA", title: "RENNEN ZUM WERTUNGSGEBIET" },
      { num: "15.11", code: "ELB", title: "ELLENBOGEN" },
      { num: "15.12", code: "LRN", title: "DREIECKSFLÄCHE" },
      { num: "15.13", code: "MDT", title: "MINIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.14", code: "SFL", title: "MINIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.15", code: "MDD", title: "MINIMUM DISTANCE ZWEI MARKER" },
      { num: "15.16", code: "XDT", title: "MAXIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.17", code: "XDI", title: "MAXIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.18", code: "XDD", title: "MAXIMUM DISTANCE ZWEI MARKER" },
      { num: "15.19", code: "ANG", title: "WINKEL" },
      { num: "15.20", code: "3DT", title: "3D-AUFGABE" },
      { num: "15.21", code: "APT", title: "HÖHENPROFIL-AUFGABE" },
    ];

    const MARKER_COLORS = ["pink","amber","emerald","sky","violet","rose","lime","orange"];
    const COLOR_HEX = {
      pink:   "#fb7185",
      amber:  "#fbbf24",
      emerald:"#34d399",
      sky:    "#38bdf8",
      violet: "#a78bfa",
      rose:   "#f43f5e",
      lime:   "#a3e635",
      orange: "#fb923c",
    };

    /********************************************************************
     * 2) GLOBALE VARIABLEN (STATE)
     ********************************************************************/
    const STATE = {
      map: null,
      layers: {
        baseOSM: null,
        baseSAT: null,
        tasksLayer: null,
        trackLayer: null,
        markersLayer: null,
        kmlLayer: null,
        trackLine: null,
      },
      ui: {
        drawerOpen: false,
        drawerTab: "task",
        followGps: true,
        base: "osm",
        windHudOpen: false,
        mapPickMode: false,
        mapPickWhich: "A",
        snackbarTimer: null,
        wakeLock: null,
        mapUserInteracting: false,
      },
      gps: {
        watchId: null,
        hasFix: false,
        fixTs: 0,
        lat: null,
        lon: null,
        altM: null,
        speedKmh: 0,
        headingDeg: 0,
        accuracyM: null,
        smoothLat: null,
        smoothLon: null,
        lastAltM: null,
        lastAltTs: null,
        lastCourseDeg: null,
        lastCourseTs: null,
        lastPanTs: 0,
      },
      sim: {
        enabled: false,
        running: false,
        lat: null,
        lon: null,
        altM: 180,
        headingDeg: 0,
        speedKmh: 0,
        vRateMps: 0,
        timer: null,
        lastTickTs: 0,
      },
      flight: {
        active: false,
        title: "",
        startedTs: 0,
        track: [],
        markers: [],
        archive: [],
      },
      wind: {
        layers: [], // { altM, fromDeg, speedKmh, ts, source }
        lastAuto: { altM: null, courseDeg: null, ts: 0 },
      },
      task: {
        active: null,      // task object
        pointsABC: { A:null, B:null, C:null }, // helper for ELB/ANG
        apt: { startTs: null }, // for APT
      },
      balloon: {
        marker: null,
      }
    };

    /********************************************************************
     * 3) HELFER-FUNKTIONEN (Math, Formatting)
     ********************************************************************/
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function now() { return Date.now(); }

    function toRad(deg) { return deg * Math.PI / 180; }
    function toDeg(rad) { return rad * 180 / Math.PI; }

    function haversineM(a, b) {
      const R = 6371000;
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(s), Math.sqrt(1-s));
      return R * c;
    }

    function bearingDeg(a, b) {
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLon = toRad(b.lon - a.lon);
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }

    function destPoint(a, bearingDegVal, distM) {
      const R = 6371000;
      const brng = toRad(bearingDegVal);
      const lat1 = toRad(a.lat);
      const lon1 = toRad(a.lon);
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(distM/R) + Math.cos(lat1)*Math.sin(distM/R)*Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(distM/R)*Math.cos(lat1), Math.cos(distM/R)-Math.sin(lat1)*Math.sin(lat2));
      return { lat: toDeg(lat2), lon: ((toDeg(lon2)+540)%360)-180 };
    }

    function angDiffDeg(a, b) {
      let d = ((a - b + 540) % 360) - 180;
      return Math.abs(d);
    }

    function fmtDist(m) {
      if (m == null || !isFinite(m)) return "–";
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m/1000).toFixed(2)} km`;
    }
    function fmtNum(n, digits=0) {
      if (n == null || !isFinite(n)) return "–";
      return n.toFixed(digits);
    }

    function safeFloat(v, fallback=null) {
      const n = parseFloat(String(v).replace(",", "."));
      return Number.isFinite(n) ? n : fallback;
    }

    function smooth(prev, next, alpha) {
      if (prev == null || !isFinite(prev)) return next;
      return prev + alpha * (next - prev);
    }

    function windToDegFrom(fromDeg) {
      return (fromDeg + 180) % 360;
    }

    function isTaskActive() { return !!STATE.task.active; }
    function getActiveTask() { return STATE.task.active; }

    function showSnackbar(msg, ms=2200) {
      const el = document.getElementById("snackbar");
      if (!el) return;
      el.textContent = msg;
      el.classList.remove("hidden");
      clearTimeout(STATE.ui.snackbarTimer);
      STATE.ui.snackbarTimer = setTimeout(() => el.classList.add("hidden"), ms);
    }

    function setToggleUI(inputEl, knobEl, on) {
      inputEl.checked = !!on;
      knobEl.style.left = on ? "1.6rem" : "0.25rem";
      knobEl.style.background = on ? "#34d399" : "#e2e8f0";
    }

    function uid() { return Math.random().toString(36).slice(2, 10); }

    function escapeXml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&apos;");
    }

    /********************************************************************
     * 4) UI-RENDER-FUNKTIONEN
     ********************************************************************/
    function updateGpsBadge() {
      const dot = document.getElementById("gpsDot");
      const txt = document.getElementById("gpsText");
      const mode = document.getElementById("modeText");
      if (!dot || !txt || !mode) return;

      if (STATE.sim.enabled) {
        dot.className = "w-2 h-2 rounded-full bg-amber-300 inline-block";
        txt.textContent = "SIM";
        mode.textContent = "SIM";
        return;
      }

      if (STATE.gps.hasFix) {
        dot.className = "w-2 h-2 rounded-full bg-emerald-400 inline-block";
        const acc = STATE.gps.accuracyM != null ? `±${Math.round(STATE.gps.accuracyM)}m` : "";
        txt.textContent = `GPS: OK ${acc}`.trim();
        mode.textContent = "LIVE";
      } else {
        dot.className = "w-2 h-2 rounded-full bg-slate-500 inline-block";
        txt.textContent = "GPS: –";
        mode.textContent = "LIVE";
      }
    }

    function updateButtons() {
      const bStart = document.getElementById("btnStartFlight");
      const bFin = document.getElementById("btnFinish");
      if (bStart) bStart.classList.toggle("hidden", STATE.flight.active);
      if (bFin) bFin.classList.toggle("hidden", !STATE.flight.active);

      const navToast = document.getElementById("navToast");
      if (navToast) navToast.classList.toggle("hidden", !isTaskActive());

      const simControls = document.getElementById("simControls");
      if (simControls) simControls.classList.toggle("hidden", !STATE.sim.enabled);

      const aptBtn = document.getElementById("btnAPTStart");
      const t = getActiveTask();
      const isAPT = t && t.code === "APT";
      if (aptBtn) aptBtn.classList.toggle("hidden", !(isAPT && STATE.flight.active));
    }

    function updateInstruments() {
      const gsEl = document.getElementById("instGS");
      const altEl = document.getElementById("instALT");
      const varEl = document.getElementById("instVAR");

      let gs = 0, alt = null, vario = null;
      if (STATE.sim.enabled) {
        gs = STATE.sim.speedKmh || 0;
        alt = STATE.sim.altM;
        vario = STATE.sim.vRateMps;
      } else {
        gs = STATE.gps.speedKmh || 0;
        alt = STATE.gps.altM;
        vario = calcVarioMps();
      }

      if (gsEl) gsEl.textContent = fmtNum(gs, 1);
      if (altEl) altEl.textContent = alt == null ? "–" : String(Math.round(alt));
      if (varEl) varEl.textContent = vario == null ? "–" : fmtNum(vario, 1);
    }

    function calcVarioMps() {
      const alt = STATE.gps.altM;
      const ts = now();
      if (alt == null || !isFinite(alt)) return null;

      if (STATE.gps.lastAltM == null) {
        STATE.gps.lastAltM = alt;
        STATE.gps.lastAltTs = ts;
        return 0;
      }
      const dt = (ts - STATE.gps.lastAltTs) / 1000;
      if (dt < 0.6) return null;

      const da = alt - STATE.gps.lastAltM;
      STATE.gps.lastAltM = alt;
      STATE.gps.lastAltTs = ts;
      return da / dt;
    }

    function updateWindHud() {
      const box = document.getElementById("windHud");
      const list = document.getElementById("windHudList");
      if (!box || !list) return;

      box.classList.toggle("hidden", !STATE.ui.windHudOpen);

      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM).slice(0, 10);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Keine Winddaten.</div>`;
        return;
      }

      list.innerHTML = items.map(w => {
        const to = windToDegFrom(w.fromDeg);
        return `
          <div class="flex items-center justify-between rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="min-w-0">
              <div class="font-extrabold mono">${Math.round(w.altM)} m</div>
              <div class="text-xs text-slate-400 truncate">${w.source || "manual"} • ${new Date(w.ts).toLocaleTimeString()}</div>
            </div>
            <div class="text-right">
              <div class="font-extrabold mono">${Math.round(w.fromDeg)}° <span class="text-xs text-slate-400">FROM</span></div>
              <div class="text-xs text-slate-300 mono">${fmtNum(w.speedKmh,1)} km/h → ${Math.round(to)}°</div>
            </div>
          </div>
        `;
      }).join("");
    }

    function updateWindPanel() {
      const list = document.getElementById("windList");
      if (!list) return;

      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Keine Schichten vorhanden.</div>`;
        return;
      }

      list.innerHTML = items.map((w, idx) => {
        return `
          <div class="flex items-center gap-2 rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
            <div class="flex-1">
              <div class="font-extrabold mono">${Math.round(w.altM)} m</div>
              <div class="text-xs text-slate-400 mono">${Math.round(w.fromDeg)}° FROM • ${fmtNum(w.speedKmh,1)} km/h</div>
            </div>
            <button data-widx="${idx}" class="btn-touch btnDelWind h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
              <i class="fa-solid fa-trash"></i>
            </button>
          </div>
        `;
      }).join("");

      list.querySelectorAll(".btnDelWind").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const idx = parseInt(e.currentTarget.getAttribute("data-widx"), 10);
          if (!Number.isFinite(idx)) return;
          STATE.wind.layers.splice(idx, 1);
          persistAll();
          updateWindPanel();
          updateWindHud();
        });
      });
    }

    function updateArchivePanel() {
      const list = document.getElementById("archiveList");
      if (!list) return;
      const items = [...STATE.flight.archive].sort((a,b)=>b.startedTs-a.startedTs);

      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Noch keine Fahrten im Archiv.</div>`;
        return;
      }

      list.innerHTML = items.map((f) => {
        const dt = new Date(f.startedTs);
        const durMin = f.endedTs ? Math.round((f.endedTs - f.startedTs)/60000) : 0;
        const mCount = (f.markers||[]).length;
        const tCount = (f.track||[]).length;
        return `
          <div class="rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
            <div class="flex items-center gap-2">
              <div class="flex-1 min-w-0">
                <div class="font-extrabold truncate">${escapeXml(f.title || "Fahrt")}</div>
                <div class="text-xs text-slate-400">${dt.toLocaleString()} • ${durMin} min • ${tCount} pts • ${mCount} marks</div>
              </div>
              <button data-fid="${f.id}" class="btn-touch btnExport h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
                <i class="fa-solid fa-file-arrow-down mr-2"></i>KML
              </button>
            </div>
          </div>
        `;
      }).join("");

      list.querySelectorAll(".btnExport").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const fid = e.currentTarget.getAttribute("data-fid");
          const f = STATE.flight.archive.find(x => x.id === fid);
          if (!f) return;
          exportFlightToKml(f);
        });
      });
    }

    function updateNavToast() {
      const toast = document.getElementById("navToast");
      const nameEl = document.getElementById("navTaskName");
      const distEl = document.getElementById("navDist");
      const recEl  = document.getElementById("navRec");
      if (!toast || !nameEl || !distEl || !recEl) return;

      const t = getActiveTask();
      toast.classList.toggle("hidden", !t);

      if (!t) return;

      nameEl.textContent = `${t.code} — ${t.title || t.typeTitle}`;

      const pos = getCurrentPos();
      if (!pos) {
        distEl.textContent = "–";
        recEl.textContent = "Keine Position";
        return;
      }

      const target = getPrimaryTarget(t);
      if (!target) {
        distEl.textContent = "–";
        recEl.textContent = "Kein Ziel";
        return;
      }

      const d = haversineM(pos, target);
      distEl.textContent = fmtDist(d);

      const rec = recommendLayerText(t, pos, target);
      recEl.textContent = rec || "–";
    }

    function setMarkerButtonColor(taskCode) {
      const btn = document.getElementById("btnMarker");
      if (!btn) return;

      // simple mapping: rotate color by task code
      const idx = Math.abs(hashStr(taskCode || "x")) % MARKER_COLORS.length;
      const c = MARKER_COLORS[idx];
      btn.style.background = COLOR_HEX[c];
      btn.style.color = "#0b1220";
    }

    function hashStr(s) {
      let h = 0;
      for (let i=0;i<s.length;i++) h = ((h<<5)-h) + s.charCodeAt(i) | 0;
      return h;
    }

    function renderTaskTypeOptions() {
      const sel = document.getElementById("taskType");
      if (!sel) return;
      sel.innerHTML = CIA_TASKS.map(t => `<option value="${t.code}">${t.num} ${t.code} — ${t.title}</option>`).join("");
    }

    function renderTaskFieldsForCode(code) {
      const wrap = document.getElementById("taskFields");
      if (!wrap) return;

      const is3DT = code === "3DT";
      const isANG = code === "ANG";
      const isLRN = code === "LRN";
      const isAPT = code === "APT";

      const commonPoint = (label, idLat, idLon) => `
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-400 mb-1">${label} Lat</div>
            <input id="${idLat}" type="number" step="0.000001" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="49.123456" />
          </div>
          <div>
            <div class="text-xs text-slate-400 mb-1">${label} Lon</div>
            <input id="${idLon}" type="number" step="0.000001" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="8.123456" />
          </div>
        </div>
      `;

      const radiusFields = `
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-400 mb-1">${is3DT ? "Innenradius (m)" : "Radius 1 (m)"}</div>
            <input id="taskR1" type="number" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 50" />
          </div>
          <div>
            <div class="text-xs text-slate-400 mb-1">${is3DT ? "Außenradius (m)" : "Radius 2 (m)"}</div>
            <input id="taskR2" type="number" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 200" />
          </div>
        </div>
      `;

      const altFields = `
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-400 mb-1">Min Höhe (m)</div>
            <input id="taskMinAlt" type="number" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="optional" />
          </div>
          <div>
            <div class="text-xs text-slate-400 mb-1">Max Höhe (m)</div>
            <input id="taskMaxAlt" type="number" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="optional" />
          </div>
        </div>
      `;

      const angFields = isANG ? `
        <div>
          <div class="text-xs text-slate-400 mb-1">Vorgegebene Richtung (°)</div>
          <input id="taskSetDir" type="number" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="0..359" />
        </div>
      ` : "";

      const abcFields = (isANG || isLRN) ? `
        <div class="grid grid-cols-1 gap-3">
          ${commonPoint("Punkt A", "taskALat", "taskALon")}
          ${commonPoint("Punkt B", "taskBLat", "taskBLon")}
          ${isLRN ? commonPoint("Punkt C", "taskCLat", "taskCLon") : ""}
        </div>
      ` : commonPoint("Ziel", "taskALat", "taskALon");

      const aptFields = isAPT ? `
        <div class="rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
          <div class="font-bold mb-2"><i class="fa-solid fa-chart-line mr-2 text-amber-300"></i>APT Profil (Zeit → Zielhöhe)</div>
          <div class="text-xs text-slate-400 mb-2">Interpretation: Profil nach Zeit seit „APT Start“. Inner Band zählt 2x, Outer Band 1x.</div>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <div class="text-xs text-slate-400 mb-1">Inner Band ± (m)</div>
              <input id="aptInner" type="number" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 25" />
            </div>
            <div>
              <div class="text-xs text-slate-400 mb-1">Outer Band ± (m)</div>
              <input id="aptOuter" type="number" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 60" />
            </div>
          </div>
          <div class="mt-2 space-y-2" id="aptPoints"></div>
          <button id="btnAddAptPoint" class="btn-touch mt-2 h-11 w-full rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
            <i class="fa-solid fa-plus mr-2"></i>Profilpunkt hinzufügen
          </button>
        </div>
      ` : "";

      wrap.innerHTML = `
        <div class="text-xs text-slate-400 mb-1">Koordinaten</div>
        ${abcFields}
        <div class="mt-3">${radiusFields}</div>
        <div class="mt-3">${angFields}</div>
        <div class="mt-3">${altFields}</div>
        ${aptFields}
      `;

      if (isAPT) {
        ensureAptUi();
      }
    }

    function updateDrawerTabUi() {
      document.querySelectorAll(".tabBtn").forEach(b => {
        const tab = b.getAttribute("data-tab");
        b.classList.toggle("bg-sky-400", tab === STATE.ui.drawerTab);
        b.classList.toggle("text-slate-950", tab === STATE.ui.drawerTab);
        b.classList.toggle("border-sky-300", tab === STATE.ui.drawerTab);
      });
      ["task","wind","setup","archive"].forEach(t => {
        const el = document.getElementById(`tab_${t}`);
        if (el) el.classList.toggle("hidden", t !== STATE.ui.drawerTab);
      });
    }

    function openDrawer(open=true) {
      STATE.ui.drawerOpen = open;
      const wrap = document.getElementById("drawerWrap");
      if (!wrap) return;
      wrap.classList.toggle("hidden", !open);
      if (open) updateDrawerTabUi();
    }

    function openMapModal(open=true) {
      const modal = document.getElementById("mapModal");
      if (!modal) return;
      modal.classList.toggle("hidden", !open);
      const tgl = document.getElementById("tglFollow");
      const knob = document.getElementById("tglFollowKnob");
      if (tgl && knob) setToggleUI(tgl, knob, STATE.ui.followGps);
    }

    /********************************************************************
     * 5) KERN-LOGIK (GPS, Map, Simulation)
     ********************************************************************/
    function initManifestAndSW() {
      // Inline manifest via data URL
      try {
        const manifest = {
          name: "CompNavAir",
          short_name: "CompNavAir",
          start_url: ".",
          display: "standalone",
          background_color: "#020617",
          theme_color: "#020617",
          icons: []
        };
        const href = "data:application/manifest+json," + encodeURIComponent(JSON.stringify(manifest));
        const link = document.createElement("link");
        link.rel = "manifest";
        link.href = href;
        document.head.appendChild(link);
      } catch {}

      // Minimal SW via Blob (best effort)
      try {
        if (!("serviceWorker" in navigator)) return;
        const swCode = `
          self.addEventListener('install', (e)=>self.skipWaiting());
          self.addEventListener('activate', (e)=>self.clients.claim());
          self.addEventListener('fetch', (e)=>{ /* passthrough */ });
        `;
        const blob = new Blob([swCode], { type: "text/javascript" });
        const url = URL.createObjectURL(blob);
        navigator.serviceWorker.register(url).catch(()=>{});
      } catch {}
    }

    function initMap() {
      const map = L.map("map", {
        zoomControl: true,
        attributionControl: true,
        zoomSnap: 0.25,
        preferCanvas: true,
      });
      STATE.map = map;

      STATE.layers.baseOSM = L.tileLayer(TILE.osm.url, { maxZoom: 19, attribution: TILE.osm.attr });
      STATE.layers.baseSAT = L.tileLayer(TILE.esri.url, { maxZoom: 19, attribution: TILE.esri.attr });

      STATE.layers.baseOSM.addTo(map);

      STATE.layers.tasksLayer = L.layerGroup().addTo(map);
      STATE.layers.trackLayer = L.layerGroup().addTo(map);
      STATE.layers.markersLayer = L.layerGroup().addTo(map);

      STATE.layers.trackLine = L.polyline([], { color: "#ef4444", weight: 4, opacity: 0.9, interactive: false }).addTo(STATE.layers.trackLayer);

      map.setView([APP.defaultCenter.lat, APP.defaultCenter.lon], APP.defaultZoom);

      map.on("dragstart", () => {
        STATE.ui.mapUserInteracting = true;
        STATE.ui.followGps = false;
        updateFollowToggleUi();
      });
      map.on("dragend", () => {
        setTimeout(()=>STATE.ui.mapUserInteracting = false, 150);
      });

      map.on("click", (e) => {
        if (!STATE.ui.mapPickMode) return;
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;

        if (STATE.ui.mapPickWhich === "A") {
          const la = document.getElementById("taskALat");
          const lo = document.getElementById("taskALon");
          if (la) la.value = lat.toFixed(6);
          if (lo) lo.value = lon.toFixed(6);
          showSnackbar("Punkt A gesetzt.");
        }
        STATE.ui.mapPickMode = false;
        const hint = document.getElementById("mapPickHint");
        if (hint) hint.classList.add("hidden");
      });

      ensureBalloonMarker();
    }

    function ensureBalloonMarker() {
      if (!STATE.map) return;

      const icon = L.divIcon({
        className: "",
        iconSize: [28, 28],
        iconAnchor: [14, 14],
        html: `
          <div class="balloon-icon">
            <div id="balloonRot" class="balloon-rot">
              <i class="fa-solid fa-location-arrow text-sky-300 drop-shadow"></i>
            </div>
          </div>
        `
      });

      const p = getCurrentPos() || APP.defaultCenter;
      STATE.balloon.marker = L.marker([p.lat, p.lon], { icon, interactive: false }).addTo(STATE.map);
    }

    function setBalloonPose(lat, lon, headingDegVal) {
      if (!STATE.balloon.marker) return;
      STATE.balloon.marker.setLatLng([lat, lon]);
      const rot = document.getElementById("balloonRot");
      if (rot) rot.style.transform = `rotate(${headingDegVal || 0}deg)`;
    }

    function setBaseLayer(which) {
      if (!STATE.map) return;
      STATE.ui.base = which;
      try {
        if (which === "sat") {
          STATE.map.removeLayer(STATE.layers.baseOSM);
          STATE.layers.baseSAT.addTo(STATE.map);
        } else {
          STATE.map.removeLayer(STATE.layers.baseSAT);
          STATE.layers.baseOSM.addTo(STATE.map);
        }
      } catch {}
    }

    function updateFollowToggleUi() {
      const tgl = document.getElementById("tglFollow");
      const knob = document.getElementById("tglFollowKnob");
      if (tgl && knob) setToggleUI(tgl, knob, STATE.ui.followGps);
    }

    function initGPS() {
      if (!("geolocation" in navigator)) {
        showSnackbar("Geolocation nicht verfügbar.");
        return;
      }

      stopGPS();
      const opts = { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 };

      STATE.gps.watchId = navigator.geolocation.watchPosition(
        (pos) => {
          try { onGpsPosition(pos); } catch (e) { console.error(e); }
        },
        (err) => {
          console.warn(err);
          STATE.gps.hasFix = false;
          updateGpsBadge();
        },
        opts
      );
    }

    function stopGPS() {
      try {
        if (STATE.gps.watchId != null) navigator.geolocation.clearWatch(STATE.gps.watchId);
      } catch {}
      STATE.gps.watchId = null;
    }

    function onGpsPosition(pos) {
      if (STATE.sim.enabled) return;

      const c = pos.coords;
      const lat = c.latitude;
      const lon = c.longitude;
      const alt = Number.isFinite(c.altitude) ? c.altitude : null;
      const spdKmh = Number.isFinite(c.speed) ? (c.speed * 3.6) : 0;
      const head = Number.isFinite(c.heading) ? c.heading : (STATE.gps.headingDeg || 0);
      const acc = Number.isFinite(c.accuracy) ? c.accuracy : null;

      // Jump guard: reject absurd jumps
      if (STATE.gps.smoothLat != null && STATE.gps.smoothLon != null) {
        const d = haversineM({ lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon }, { lat, lon });
        const dyn = clamp((spdKmh/3.6) * 3 + 60, 80, 220); // 3s window + margin
        if (d > Math.max(APP.maxGpsJumpM, dyn)) {
          // ignore this fix
          return;
        }
      }

      // smoothing
      STATE.gps.smoothLat = smooth(STATE.gps.smoothLat, lat, APP.gpsSmoothingAlpha);
      STATE.gps.smoothLon = smooth(STATE.gps.smoothLon, lon, APP.gpsSmoothingAlpha);

      STATE.gps.lat = STATE.gps.smoothLat;
      STATE.gps.lon = STATE.gps.smoothLon;
      STATE.gps.altM = alt;
      STATE.gps.speedKmh = spdKmh;
      STATE.gps.headingDeg = head;
      STATE.gps.accuracyM = acc;

      STATE.gps.hasFix = true;
      STATE.gps.fixTs = now();

      // Update marker & optional follow
      setBalloonPose(STATE.gps.lat, STATE.gps.lon, head);

      if (STATE.ui.followGps && !STATE.ui.mapUserInteracting) {
        const ts = now();
        if (ts - STATE.gps.lastPanTs > APP.followPanMinMs) {
          STATE.gps.lastPanTs = ts;
          STATE.map?.panTo([STATE.gps.lat, STATE.gps.lon], { animate: true, duration: 0.35 });
        }
      }

      // Only log track/wind if flight is active (NO AUTO START!)
      if (STATE.flight.active) {
        maybeAddTrackPoint({ lat: STATE.gps.lat, lon: STATE.gps.lon, altM: alt, ts: now() });
        maybeAutoRecordWind({ altM: alt, courseDeg: head, speedKmh: spdKmh, ts: now() });
      }

      updateGpsBadge();
      updateInstruments();
      updateNavToast();
      updateWindHud();
      persistAllThrottled();
    }

    function getCurrentPos() {
      if (STATE.sim.enabled && STATE.sim.lat != null && STATE.sim.lon != null) {
        return { lat: STATE.sim.lat, lon: STATE.sim.lon };
      }
      if (!STATE.gps.hasFix || STATE.gps.lat == null || STATE.gps.lon == null) return null;
      return { lat: STATE.gps.lat, lon: STATE.gps.lon };
    }

    function getCurrentAltM() {
      if (STATE.sim.enabled) return STATE.sim.altM;
      return STATE.gps.altM;
    }

    function beginFlight(title) {
      if (STATE.flight.active) return;

      STATE.flight.active = true;
      STATE.flight.title = title || (getActiveTask() ? `${getActiveTask().code} — ${getActiveTask().title||getActiveTask().typeTitle}` : "Fahrt");
      STATE.flight.startedTs = now();
      STATE.flight.track = [];
      STATE.flight.markers = [];

      // Clear map layers for current flight
      try { STATE.layers.trackLine?.setLatLngs([]); } catch {}
      try { STATE.layers.markersLayer?.clearLayers(); } catch {}

      // Reset helpers
      STATE.gps.lastAltM = null;
      STATE.gps.lastAltTs = null;
      STATE.wind.lastAuto = { altM: null, courseDeg: null, ts: 0 };

      // Reset APT timer start (must be started explicitly)
      STATE.task.apt.startTs = null;

      updateButtons();
      showSnackbar("Fahrt gestartet.");
      persistAll();
    }

    function finishFlight() {
      if (!STATE.flight.active) return;

      const endedTs = now();
      const flight = {
        id: uid(),
        title: STATE.flight.title || "Fahrt",
        startedTs: STATE.flight.startedTs,
        endedTs,
        track: STATE.flight.track.slice(0),
        markers: STATE.flight.markers.slice(0),
      };

      STATE.flight.archive.push(flight);
      STATE.flight.active = false;
      STATE.flight.title = "";
      STATE.flight.startedTs = 0;
      STATE.task.apt.startTs = null;

      updateButtons();
      updateArchivePanel();
      showSnackbar("Fahrt beendet & archiviert.");
      persistAll();
    }

    function maybeAddTrackPoint(p) {
      if (!STATE.flight.active) return;
      if (!p || p.lat == null || p.lon == null) return;

      const track = STATE.flight.track;
      if (track.length) {
        const last = track[track.length-1];
        const d = haversineM({ lat:last.lat, lon:last.lon }, { lat:p.lat, lon:p.lon });
        if (d < APP.trackMinDistM) return;
      }

      track.push({ lat:p.lat, lon:p.lon, altM:p.altM, ts:p.ts });
      if (track.length > APP.maxTrackPoints) track.shift();

      try {
        const latlngs = track.map(x => [x.lat, x.lon]);
        STATE.layers.trackLine?.setLatLngs(latlngs);
      } catch {}
    }

    function maybeAutoRecordWind({ altM, courseDeg, speedKmh, ts }) {
      if (!STATE.flight.active) return;
      if (speedKmh == null || speedKmh < 10) return;
      if (altM == null || !isFinite(altM)) return;

      const last = STATE.wind.lastAuto;
      const dAlt = last.altM == null ? 9999 : Math.abs(altM - last.altM);
      const dCrs = last.courseDeg == null ? 9999 : angDiffDeg(courseDeg, last.courseDeg);

      if (dAlt > 50 || dCrs > 5) {
        const fromDeg = (courseDeg + 180) % 360;
        addWindLayer({ altM, fromDeg, speedKmh, ts, source: "auto" });
        STATE.wind.lastAuto = { altM, courseDeg, ts };
      }
    }

    function addWindLayer(w) {
      const alt = Math.round(w.altM);
      const from = ((Math.round(w.fromDeg)%360)+360)%360;
      const spd = Math.max(0, safeFloat(w.speedKmh, 0));
      const ts = w.ts || now();

      // replace if same altitude bucket
      const idx = STATE.wind.layers.findIndex(x => Math.abs(x.altM - alt) <= 15);
      const item = { altM: alt, fromDeg: from, speedKmh: spd, ts, source: w.source || "manual" };
      if (idx >= 0) STATE.wind.layers[idx] = item;
      else STATE.wind.layers.push(item);

      // keep sorted-ish
      STATE.wind.layers.sort((a,b)=>a.altM-b.altM);
      persistAll();
      updateWindPanel();
      updateWindHud();
      updateNavToast();
    }

    function windAtAltitude(altM) {
      if (!STATE.wind.layers.length || altM == null) return null;
      let best = null, bestD = Infinity;
      for (const w of STATE.wind.layers) {
        const d = Math.abs(w.altM - altM);
        if (d < bestD) { bestD = d; best = w; }
      }
      return best;
    }

    function recommendLayerText(task, pos, target) {
      // Special 3DT donut strategy if R1/R2 present
      if (task && task.code === "3DT" && task.center && task.r1M && task.r2M) {
        const dC = haversineM(pos, task.center);
        if (dC < task.r1M) return "Ungültig (im inneren Kreis)";
        if (dC <= task.r2M) return "Im Ring: Distanz maximieren";
        return "Außerhalb: Ziel = Zentrum";
      }

      // APT scoring indicator (time in bands)
      if (task && task.code === "APT") {
        const scoreTxt = aptScoreText();
        if (scoreTxt) return scoreTxt;
      }

      // Default: best wind layer = drift direction closest to bearing-to-target
      if (!STATE.wind.layers.length) return "Kein Windprofil";
      const brg = bearingDeg(pos, target);

      let best = null;
      let bestScore = Infinity;
      for (const w of STATE.wind.layers) {
        const driftTo = windToDegFrom(w.fromDeg);
        const score = angDiffDeg(driftTo, brg);
        if (score < bestScore) { bestScore = score; best = w; }
      }
      if (!best) return "Kein Layer";

      const curAlt = getCurrentAltM();
      const need = Math.round(best.altM);
      if (curAlt == null) return `Layer: ${need}m`;
      const dAlt = need - curAlt;
      if (Math.abs(dAlt) < 25) return `Halten ~${need}m`;
      return dAlt > 0 ? `Steigen auf ${need}m` : `Sinken auf ${need}m`;
    }

    function clearTaskOverlays() {
      try { STATE.layers.tasksLayer?.clearLayers(); } catch {}
    }

    function drawTaskOnMap(task) {
      clearTaskOverlays();
      if (!task || !STATE.map) return;

      // Non-interactive overlays are CRITICAL (fix for 3DT covering the map)
      const NI = { interactive: false };

      // Primary points
      if (task.points && task.points.length) {
        task.points.forEach((p, idx) => {
          const color = idx === 0 ? "#60a5fa" : "#93c5fd";
          L.circleMarker([p.lat, p.lon], {
            radius: 9,
            color,
            weight: 3,
            fillColor: color,
            fillOpacity: 0.25,
            ...NI
          }).addTo(STATE.layers.tasksLayer);

          // tiny label via separate non-interactive marker
          L.marker([p.lat, p.lon], {
            icon: L.divIcon({
              className: "",
              iconSize: [1,1],
              html: `<div class="mono text-xs font-extrabold text-sky-200 drop-shadow">${escapeXml(p.name||String.fromCharCode(65+idx))}</div>`
            }),
            interactive: false
          }).addTo(STATE.layers.tasksLayer);
        });
      }

      // Donut / radius circles for 3DT or generic
      const center = task.center || (task.points && task.points[0] ? { lat: task.points[0].lat, lon: task.points[0].lon } : null);
      if (center && (task.r2M || task.r1M)) {
        if (task.r2M) {
          L.circle([center.lat, center.lon], {
            radius: task.r2M,
            color: "#60a5fa",
            weight: 3,
            opacity: 0.9,
            fillOpacity: 0.05,
            ...NI
          }).addTo(STATE.layers.tasksLayer);
        }
        if (task.r1M) {
          L.circle([center.lat, center.lon], {
            radius: task.r1M,
            color: "#93c5fd",
            weight: 2,
            opacity: 0.8,
            dashArray: "6 8",
            fillOpacity: 0.01,
            ...NI
          }).addTo(STATE.layers.tasksLayer);
        }
      }

      // Lines for ANG / LRN
      if (task.code === "ANG" && task.points && task.points.length >= 2) {
        L.polyline(task.points.slice(0,2).map(p => [p.lat,p.lon]), { color:"#38bdf8", weight:3, opacity:0.9, dashArray:"8 8", ...NI }).addTo(STATE.layers.tasksLayer);
      }
      if (task.code === "LRN" && task.points && task.points.length >= 3) {
        L.polyline(task.points.slice(0,3).map(p => [p.lat,p.lon]).concat([[task.points[0].lat, task.points[0].lon]]), { color:"#38bdf8", weight:3, opacity:0.9, ...NI }).addTo(STATE.layers.tasksLayer);
      }
    }

    function getPrimaryTarget(task) {
      if (!task) return null;
      if (task.code === "3DT" && task.center) return task.center;
      if (task.points && task.points.length) return { lat: task.points[0].lat, lon: task.points[0].lon };
      return null;
    }

    function dropMarker() {
      if (!STATE.flight.active) {
        showSnackbar("Bitte zuerst die Fahrt starten.");
        return;
      }
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position."); return; }

      const alt = getCurrentAltM();
      const t = getActiveTask();
      const colorKey = t ? MARKER_COLORS[Math.abs(hashStr(t.code)) % MARKER_COLORS.length] : "pink";
      const color = COLOR_HEX[colorKey];

      const m = {
        lat: pos.lat,
        lon: pos.lon,
        altM: alt,
        ts: now(),
        color: colorKey,
        label: t ? t.code : "MARK",
      };
      STATE.flight.markers.push(m);

      // Draw
      L.circleMarker([m.lat, m.lon], {
        radius: 8,
        color,
        weight: 3,
        fillColor: color,
        fillOpacity: 0.25,
        interactive: false
      }).addTo(STATE.layers.markersLayer);

      showSnackbar("Marker gesetzt.");
      persistAll();
    }

    function exportFlightToKml(f) {
      try {
        const name = escapeXml(f.title || APP.kmlName);
        const trackCoords = (f.track || []).map(p => `${p.lon},${p.lat},${p.altM||0}`).join(" ");
        const markerPlacemarks = (f.markers || []).map(m => {
          const when = new Date(m.ts).toISOString();
          return `
            <Placemark>
              <name>${escapeXml(m.label || "MARK")}</name>
              <TimeStamp><when>${when}</when></TimeStamp>
              <Point><coordinates>${m.lon},${m.lat},${m.altM||0}</coordinates></Point>
            </Placemark>
          `;
        }).join("\n");

        const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Style id="trackStyle"><LineStyle><color>ff4f46e5</color><width>4</width></LineStyle></Style>
    <Placemark>
      <name>Track</name>
      <styleUrl>#trackStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <altitudeMode>absolute</altitudeMode>
        <coordinates>${trackCoords}</coordinates>
      </LineString>
    </Placemark>
    ${markerPlacemarks}
  </Document>
</kml>`;

        const blob = new Blob([kml], { type: "application/vnd.google-earth.kml+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        const ts = new Date(f.startedTs).toISOString().slice(0,19).replaceAll(":","-");
        a.download = `CompNavAir_${ts}.kml`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
      } catch (e) {
        console.error(e);
        showSnackbar("KML Export fehlgeschlagen.");
      }
    }

    async function fetchWindFromOpenMeteo() {
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position für Online-Wind."); return; }

      const lat = pos.lat.toFixed(4);
      const lon = pos.lon.toFixed(4);

      // Use multiple "standard" heights where available
      const hourly = [
        "windspeed_10m","winddirection_10m",
        "windspeed_80m","winddirection_80m",
        "windspeed_120m","winddirection_120m",
        "windspeed_180m","winddirection_180m"
      ].join(",");

      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=${hourly}&forecast_days=1&timezone=auto`;

      try {
        showSnackbar("Lade Wind…", 1200);
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error("HTTP " + r.status);
        const j = await r.json();

        const h = j.hourly;
        if (!h || !h.time || !h.time.length) throw new Error("no hourly data");

        // Pick closest hour to now
        const tNow = now();
        let bestI = 0, bestD = Infinity;
        for (let i=0;i<h.time.length;i++) {
          const t = Date.parse(h.time[i]);
          const d = Math.abs(t - tNow);
          if (d < bestD) { bestD = d; bestI = i; }
        }

        const mapping = [
          { altM: 10,  spd: h.windspeed_10m?.[bestI],  dir: h.winddirection_10m?.[bestI] },
          { altM: 80,  spd: h.windspeed_80m?.[bestI],  dir: h.winddirection_80m?.[bestI] },
          { altM: 120, spd: h.windspeed_120m?.[bestI], dir: h.winddirection_120m?.[bestI] },
          { altM: 180, spd: h.windspeed_180m?.[bestI], dir: h.winddirection_180m?.[bestI] },
        ];

        let added = 0;
        for (const m of mapping) {
          if (m.spd == null || m.dir == null) continue;
          addWindLayer({ altM: m.altM, fromDeg: m.dir, speedKmh: m.spd, ts: now(), source: "open-meteo" });
          added++;
        }
        showSnackbar(added ? `Wind geladen (${added} Schichten).` : "Keine Windschichten gefunden.");
      } catch (e) {
        console.error(e);
        showSnackbar("Online-Wind fehlgeschlagen.");
      }
    }

    function initSimulationToggle(enabled) {
      STATE.sim.enabled = !!enabled;
      updateButtons();
      updateGpsBadge();

      if (STATE.sim.enabled) {
        // Pause GPS and set sim start at current gps or default
        stopGPS();
        const p = getCurrentPos() || APP.defaultCenter;
        STATE.sim.lat = p.lat;
        STATE.sim.lon = p.lon;
        STATE.sim.altM = getCurrentAltM() || 180;
        STATE.sim.vRateMps = 0;
        STATE.sim.speedKmh = 0;
        STATE.sim.headingDeg = 0;

        setBalloonPose(STATE.sim.lat, STATE.sim.lon, STATE.sim.headingDeg);
        STATE.map?.panTo([STATE.sim.lat, STATE.sim.lon], { animate:true, duration:0.35 });

        startSimLoop();
        showSnackbar("Simulation an.");
      } else {
        stopSimLoop();
        initGPS();
        showSnackbar("Simulation aus.");
      }
      persistAll();
    }

    function startSimLoop() {
      if (STATE.sim.timer) return;
      STATE.sim.running = true;
      STATE.sim.lastTickTs = now();
      STATE.sim.timer = setInterval(() => {
        try { simTick(); } catch (e) { console.error(e); }
      }, 1000);
    }

    function stopSimLoop() {
      STATE.sim.running = false;
      try { clearInterval(STATE.sim.timer); } catch {}
      STATE.sim.timer = null;
      STATE.sim.vRateMps = 0;
    }

    function simTick() {
      if (!STATE.sim.enabled) return;
      const t = now();
      const dt = Math.min(2.5, Math.max(0.4, (t - STATE.sim.lastTickTs)/1000));
      STATE.sim.lastTickTs = t;

      // Vertical
      STATE.sim.altM = Math.max(0, (STATE.sim.altM || 0) + (STATE.sim.vRateMps || 0) * dt);

      // Horizontal drift from wind at altitude
      const w = windAtAltitude(STATE.sim.altM);
      let driftTo = 0, spd = 0;
      if (w) {
        driftTo = windToDegFrom(w.fromDeg);
        spd = Math.max(0, w.speedKmh || 0);
      }
      const distM = (spd/3.6) * dt;
      const p = destPoint({ lat: STATE.sim.lat, lon: STATE.sim.lon }, driftTo, distM);
      STATE.sim.lat = p.lat;
      STATE.sim.lon = p.lon;
      STATE.sim.headingDeg = driftTo;
      STATE.sim.speedKmh = spd;

      setBalloonPose(STATE.sim.lat, STATE.sim.lon, STATE.sim.headingDeg);

      if (STATE.ui.followGps && !STATE.ui.mapUserInteracting) {
        const ts = now();
        if (ts - STATE.gps.lastPanTs > APP.followPanMinMs) {
          STATE.gps.lastPanTs = ts;
          STATE.map?.panTo([STATE.sim.lat, STATE.sim.lon], { animate:true, duration:0.35 });
        }
      }

      // Track log if flight active
      if (STATE.flight.active) {
        maybeAddTrackPoint({ lat: STATE.sim.lat, lon: STATE.sim.lon, altM: STATE.sim.altM, ts: now() });
      }

      updateInstruments();
      updateNavToast();
      updateWindHud();
      persistAllThrottled();
    }

    function handleBurner(pressed) {
      if (!STATE.sim.enabled) return;
      STATE.sim.vRateMps = pressed ? 2.5 : 0;
    }
    function handleVent(pressed) {
      if (!STATE.sim.enabled) return;
      STATE.sim.vRateMps = pressed ? -2.0 : 0;
    }

    function centerOnPos() {
      const p = getCurrentPos();
      if (!p || !STATE.map) return;
      STATE.ui.followGps = true;
      updateFollowToggleUi();
      STATE.map.panTo([p.lat, p.lon], { animate:true, duration:0.35 });
      showSnackbar("Zentriert.");
    }

    function buildTaskFromForm() {
      const code = document.getElementById("taskType")?.value;
      const meta = CIA_TASKS.find(x => x.code === code);
      if (!code || !meta) return null;

      const title = document.getElementById("taskTitle")?.value?.trim() || "";
      const r1 = safeFloat(document.getElementById("taskR1")?.value, null);
      const r2 = safeFloat(document.getElementById("taskR2")?.value, null);
      const minAlt = safeFloat(document.getElementById("taskMinAlt")?.value, null);
      const maxAlt = safeFloat(document.getElementById("taskMaxAlt")?.value, null);

      const points = [];
      const aLat = safeFloat(document.getElementById("taskALat")?.value, null);
      const aLon = safeFloat(document.getElementById("taskALon")?.value, null);
      if (aLat != null && aLon != null) points.push({ name:"A", lat:aLat, lon:aLon });

      const bLat = safeFloat(document.getElementById("taskBLat")?.value, null);
      const bLon = safeFloat(document.getElementById("taskBLon")?.value, null);
      if (bLat != null && bLon != null) points.push({ name:"B", lat:bLat, lon:bLon });

      const cLat = safeFloat(document.getElementById("taskCLat")?.value, null);
      const cLon = safeFloat(document.getElementById("taskCLon")?.value, null);
      if (cLat != null && cLon != null) points.push({ name:"C", lat:cLat, lon:cLon });

      const setDir = safeFloat(document.getElementById("taskSetDir")?.value, null);

      const task = {
        id: uid(),
        code,
        typeTitle: meta.title,
        title,
        points,
        r1M: r1 != null ? Math.max(0, r1) : null,
        r2M: r2 != null ? Math.max(0, r2) : null,
        minAltM: minAlt,
        maxAltM: maxAlt,
        setDirDeg: setDir != null ? ((setDir%360)+360)%360 : null,
        center: null,
        apt: null,
      };

      // Center definition
      if (task.code === "3DT") {
        // For donut: use A as center (if exists)
        if (points[0]) task.center = { lat: points[0].lat, lon: points[0].lon };
      }

      if (task.code === "APT") {
        task.apt = readAptFromUi();
      }

      return task;
    }

    function applyTask() {
      const task = buildTaskFromForm();
      if (!task) { showSnackbar("Task unvollständig."); return; }

      // Basic validation: need at least A for most tasks
      if (task.code !== "APT" && (!task.points || !task.points.length)) {
        showSnackbar("Bitte Koordinaten (mind. Punkt A) eingeben.");
        return;
      }

      STATE.task.active = task;
      drawTaskOnMap(task);
      updateButtons();
      updateNavToast();
      setMarkerButtonColor(task.code);

      // Zoom to task
      try {
        const latlngs = [];
        if (task.points) task.points.forEach(p => latlngs.push([p.lat,p.lon]));
        if (task.center) latlngs.push([task.center.lat, task.center.lon]);
        if (latlngs.length) {
          const b = L.latLngBounds(latlngs);
          STATE.map.fitBounds(b.pad(0.35), { animate:true, duration:0.4 });
        }
      } catch {}

      showSnackbar("Task aktiv.");
      persistAll();
    }

    function clearTask() {
      STATE.task.active = null;
      clearTaskOverlays();
      updateButtons();
      updateNavToast();
      setMarkerButtonColor("x");
      showSnackbar("Task gelöscht.");
      persistAll();
    }

    function enableMapPick() {
      STATE.ui.mapPickMode = true;
      STATE.ui.mapPickWhich = "A";
      const hint = document.getElementById("mapPickHint");
      if (hint) hint.classList.remove("hidden");
      showSnackbar("Tippe auf die Karte, um Punkt A zu setzen.");
    }

    function setHelperPoint(which) {
      if (!STATE.flight.active) { showSnackbar("Nur während aktiver Fahrt."); return; }
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position."); return; }
      STATE.task.pointsABC[which] = { ...pos };
      showSnackbar(`Punkt ${which} gesetzt.`);
      updateElbowResult();
    }

    function updateElbowResult() {
      const out = document.getElementById("elbowResult");
      if (!out) return;
      const A = STATE.task.pointsABC.A;
      const B = STATE.task.pointsABC.B;
      const C = STATE.task.pointsABC.C;
      if (!A || !B || !C) { out.textContent = "–"; return; }

      // Angle ABC
      const brgBA = bearingDeg(B, A);
      const brgBC = bearingDeg(B, C);
      let ang = angDiffDeg(brgBA, brgBC); // 0..180
      // ELB result = 180 - angle ABC
      const res = 180 - ang;
      out.textContent = fmtNum(res, 1);
    }

    function ensureAptUi() {
      const wrap = document.getElementById("aptPoints");
      const btn = document.getElementById("btnAddAptPoint");
      if (!wrap || !btn) return;

      // If no points, add default 0 min / 200m
      if (!wrap.childElementCount) {
        addAptRow(0, 200);
        addAptRow(10, 250);
      }

      btn.onclick = () => addAptRow(0, 200);
    }

    function addAptRow(min, alt) {
      const wrap = document.getElementById("aptPoints");
      if (!wrap) return;
      const rowId = uid();
      const el = document.createElement("div");
      el.className = "flex items-center gap-2";
      el.innerHTML = `
        <input data-apt="min" type="number" class="h-11 w-24 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="min" value="${min ?? ""}">
        <div class="text-slate-400 text-sm">→</div>
        <input data-apt="alt" type="number" class="h-11 flex-1 rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="Zielhöhe m" value="${alt ?? ""}">
        <button data-apt="del" class="btn-touch h-11 w-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
          <i class="fa-solid fa-trash"></i>
        </button>
      `;
      el.querySelector('[data-apt="del"]').addEventListener("click", () => el.remove());
      wrap.appendChild(el);
    }

    function readAptFromUi() {
      const inner = safeFloat(document.getElementById("aptInner")?.value, 25);
      const outer = safeFloat(document.getElementById("aptOuter")?.value, 60);
      const wrap = document.getElementById("aptPoints");
      const pts = [];
      if (wrap) {
        wrap.querySelectorAll(":scope > div").forEach(row => {
          const m = safeFloat(row.querySelector('[data-apt="min"]')?.value, null);
          const a = safeFloat(row.querySelector('[data-apt="alt"]')?.value, null);
          if (m != null && a != null) pts.push({ min: m, altM: a });
        });
      }
      pts.sort((x,y)=>x.min-y.min);
      return { innerBandM: Math.max(0, inner), outerBandM: Math.max(0, outer), profile: pts };
    }

    function startAPT() {
      if (!STATE.flight.active) { showSnackbar("APT Start nur während Fahrt."); return; }
      STATE.task.apt.startTs = now();
      showSnackbar("APT Start gesetzt.");
      persistAll();
      updateNavToast();
    }

    function aptTargetAltAt(elapsedMin, task) {
      const apt = task?.apt;
      if (!apt || !apt.profile || apt.profile.length === 0) return null;
      const p = apt.profile;

      if (elapsedMin <= p[0].min) return p[0].altM;
      if (elapsedMin >= p[p.length-1].min) return p[p.length-1].altM;

      for (let i=0;i<p.length-1;i++) {
        const a = p[i], b = p[i+1];
        if (elapsedMin >= a.min && elapsedMin <= b.min) {
          const t = (elapsedMin - a.min) / (b.min - a.min);
          return a.altM + t * (b.altM - a.altM);
        }
      }
      return null;
    }

    function aptScoreText() {
      const task = getActiveTask();
      if (!task || task.code !== "APT") return null;
      if (!STATE.task.apt.startTs) return "APT: Start fehlt";

      const alt = getCurrentAltM();
      if (alt == null) return "APT: ALT fehlt";

      const elapsedMin = (now() - STATE.task.apt.startTs) / 60000;
      const target = aptTargetAltAt(elapsedMin, task);
      if (target == null) return "APT: Profil fehlt";

      const inner = task.apt?.innerBandM ?? 25;
      const outer = task.apt?.outerBandM ?? 60;
      const d = Math.abs(alt - target);

      if (d <= inner) return `APT: 2x (Δ${Math.round(d)}m)`;
      if (d <= outer) return `APT: 1x (Δ${Math.round(d)}m)`;
      return `APT: 0x (Δ${Math.round(d)}m)`;
    }

    function importKmlFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const txt = String(reader.result || "");
          if (STATE.layers.kmlLayer) {
            try { STATE.map.removeLayer(STATE.layers.kmlLayer); } catch {}
            STATE.layers.kmlLayer = null;
          }
          const layer = omnivore.kml.parse(txt);
          layer.eachLayer(l => {
            // Make overlays non-interactive to avoid blocking
            if (l && typeof l.options === "object") l.options.interactive = false;
          });
          layer.addTo(STATE.map);
          STATE.layers.kmlLayer = layer;
          showSnackbar("KML importiert.");
        } catch (e) {
          console.error(e);
          showSnackbar("KML Import fehlgeschlagen.");
        }
      };
      reader.readAsText(file);
    }

    async function requestWakeLock() {
      try {
        if (!("wakeLock" in navigator)) { showSnackbar("Wake Lock nicht unterstützt."); return; }
        STATE.ui.wakeLock = await navigator.wakeLock.request("screen");
        showSnackbar("Wake Lock aktiv.");
        STATE.ui.wakeLock.addEventListener("release", () => {});
      } catch (e) {
        console.warn(e);
        showSnackbar("Wake Lock fehlgeschlagen.");
      }
    }

    function releaseWakeLock() {
      try { STATE.ui.wakeLock?.release(); } catch {}
      STATE.ui.wakeLock = null;
    }

    /********************************************************************
     * Persistenz
     ********************************************************************/
    let _persistT = 0;
    function persistAllThrottled() {
      const t = now();
      if (t - _persistT < 1500) return;
      _persistT = t;
      persistAll();
    }

    function persistAll() {
      try {
        const payload = {
          version: APP.version,
          ui: {
            followGps: STATE.ui.followGps,
            base: STATE.ui.base,
          },
          wind: {
            layers: STATE.wind.layers,
          },
          task: {
            active: STATE.task.active,
            aptStartTs: STATE.task.apt.startTs,
          },
          flight: {
            active: STATE.flight.active,
            title: STATE.flight.title,
            startedTs: STATE.flight.startedTs,
            track: STATE.flight.track,
            markers: STATE.flight.markers,
            archive: STATE.flight.archive,
          },
          sim: {
            enabled: STATE.sim.enabled,
          }
        };
        localStorage.setItem(APP.storageKey, JSON.stringify(payload));
      } catch {}
    }

    function restoreAll() {
      try {
        const raw = localStorage.getItem(APP.storageKey);
        if (!raw) return;
        const j = JSON.parse(raw);

        if (j.ui) {
          STATE.ui.followGps = !!j.ui.followGps;
          STATE.ui.base = j.ui.base === "sat" ? "sat" : "osm";
        }

        if (j.wind && Array.isArray(j.wind.layers)) {
          STATE.wind.layers = j.wind.layers.filter(x => x && isFinite(x.altM));
        }

        if (j.task) {
          STATE.task.active = j.task.active || null;
          STATE.task.apt.startTs = j.task.aptStartTs || null;
        }

        if (j.flight) {
          STATE.flight.active = !!j.flight.active;
          STATE.flight.title = j.flight.title || "";
          STATE.flight.startedTs = j.flight.startedTs || 0;
          STATE.flight.track = Array.isArray(j.flight.track) ? j.flight.track : [];
          STATE.flight.markers = Array.isArray(j.flight.markers) ? j.flight.markers : [];
          STATE.flight.archive = Array.isArray(j.flight.archive) ? j.flight.archive : [];
        }

        if (j.sim) {
          STATE.sim.enabled = !!j.sim.enabled;
        }
      } catch {}
    }

    function restoreFormFromTask(task) {
      if (!task) return;
      const typeSel = document.getElementById("taskType");
      const titleIn = document.getElementById("taskTitle");
      if (typeSel) typeSel.value = task.code;
      if (titleIn) titleIn.value = task.title || "";

      renderTaskFieldsForCode(task.code);

      const setVal = (id, val) => { const el = document.getElementById(id); if (el && val != null) el.value = val; };

      if (task.points && task.points[0]) { setVal("taskALat", task.points[0].lat); setVal("taskALon", task.points[0].lon); }
      if (task.points && task.points[1]) { setVal("taskBLat", task.points[1].lat); setVal("taskBLon", task.points[1].lon); }
      if (task.points && task.points[2]) { setVal("taskCLat", task.points[2].lat); setVal("taskCLon", task.points[2].lon); }

      setVal("taskR1", task.r1M);
      setVal("taskR2", task.r2M);
      setVal("taskMinAlt", task.minAltM);
      setVal("taskMaxAlt", task.maxAltM);
      setVal("taskSetDir", task.setDirDeg);

      if (task.code === "APT" && task.apt) {
        const inner = document.getElementById("aptInner");
        const outer = document.getElementById("aptOuter");
        if (inner) inner.value = task.apt.innerBandM ?? "";
        if (outer) outer.value = task.apt.outerBandM ?? "";
        const wrap = document.getElementById("aptPoints");
        if (wrap) wrap.innerHTML = "";
        if (task.apt.profile && task.apt.profile.length) {
          task.apt.profile.forEach(p => addAptRow(p.min, p.altM));
        } else {
          ensureAptUi();
        }
      }
    }

    /********************************************************************
     * 6) EVENT-LISTENER & INITIALISIERUNG (window.onload am Ende)
     ********************************************************************/
    window.onload = () => {
      initManifestAndSW();

      restoreAll();

      initMap();
      setBaseLayer(STATE.ui.base);

      // UI init
      renderTaskTypeOptions();
      renderTaskFieldsForCode(document.getElementById("taskType")?.value || "JDG");

      // restore task into form and map
      if (STATE.task.active) {
        restoreFormFromTask(STATE.task.active);
        drawTaskOnMap(STATE.task.active);
        setMarkerButtonColor(STATE.task.active.code);
      } else {
        setMarkerButtonColor("x");
      }

      // restore flight visuals if flight active
      if (STATE.flight.active) {
        try {
          const latlngs = (STATE.flight.track||[]).map(p => [p.lat,p.lon]);
          STATE.layers.trackLine?.setLatLngs(latlngs);
        } catch {}
        try {
          (STATE.flight.markers||[]).forEach(m => {
            const color = COLOR_HEX[m.color] || COLOR_HEX.pink;
            L.circleMarker([m.lat,m.lon], { radius:8, color, weight:3, fillColor:color, fillOpacity:0.25, interactive:false })
              .addTo(STATE.layers.markersLayer);
          });
        } catch {}
      }

      updateGpsBadge();
      updateButtons();
      updateInstruments();
      updateNavToast();
      updateWindHud();
      updateWindPanel();
      updateArchivePanel();
      updateElbowResult();
      updateFollowToggleUi();

      // Drawer tab buttons
      document.querySelectorAll(".tabBtn").forEach(b => {
        b.addEventListener("click", () => {
          STATE.ui.drawerTab = b.getAttribute("data-tab");
          updateDrawerTabUi();
        });
      });

      // Drawer open/close
      document.getElementById("btnMenu")?.addEventListener("click", () => openDrawer(true));
      document.getElementById("btnDrawerClose")?.addEventListener("click", () => openDrawer(false));
      document.getElementById("drawerBg")?.addEventListener("click", () => openDrawer(false));

      // Header buttons
      document.getElementById("btnWindHud")?.addEventListener("click", () => {
        STATE.ui.windHudOpen = !STATE.ui.windHudOpen;
        updateWindHud();
      });
      document.getElementById("btnWindClose")?.addEventListener("click", () => {
        STATE.ui.windHudOpen = false;
        updateWindHud();
      });
      document.getElementById("btnWindFetch")?.addEventListener("click", fetchWindFromOpenMeteo);

      document.getElementById("btnMapSettings")?.addEventListener("click", () => openMapModal(true));
      document.getElementById("btnMapModalClose")?.addEventListener("click", () => openMapModal(false));
      document.getElementById("mapModalBg")?.addEventListener("click", () => openMapModal(false));

      document.getElementById("btnBaseOSM")?.addEventListener("click", () => { setBaseLayer("osm"); persistAll(); });
      document.getElementById("btnBaseSAT")?.addEventListener("click", () => { setBaseLayer("sat"); persistAll(); });

      document.getElementById("btnCenter")?.addEventListener("click", centerOnPos);

      // Follow toggle
      document.getElementById("tglFollow")?.addEventListener("change", (e) => {
        STATE.ui.followGps = !!e.target.checked;
        updateFollowToggleUi();
        persistAll();
      });

      // Flight controls
      document.getElementById("btnStartFlight")?.addEventListener("click", () => {
        const t = getActiveTask();
        const title = t ? `${t.code} — ${t.title || t.typeTitle}` : "Fahrt";
        beginFlight(title);
      });
      document.getElementById("btnFinish")?.addEventListener("click", finishFlight);

      // Marker
      document.getElementById("btnMarker")?.addEventListener("click", dropMarker);

      // Task form
      document.getElementById("taskType")?.addEventListener("change", (e) => {
        const code = e.target.value;
        renderTaskFieldsForCode(code);
        setMarkerButtonColor(code);
        persistAll();
      });

      document.getElementById("btnApplyTask")?.addEventListener("click", applyTask);
      document.getElementById("btnClearTask")?.addEventListener("click", clearTask);

      document.getElementById("btnSetTargetFromMap")?.addEventListener("click", enableMapPick);

      document.getElementById("btnAPTStart")?.addEventListener("click", startAPT);

      // ELB helper buttons
      document.getElementById("btnSetA")?.addEventListener("click", () => setHelperPoint("A"));
      document.getElementById("btnSetB")?.addEventListener("click", () => setHelperPoint("B"));
      document.getElementById("btnSetC")?.addEventListener("click", () => setHelperPoint("C"));

      // Wind panel
      document.getElementById("btnAddWind")?.addEventListener("click", () => {
        const alt = safeFloat(document.getElementById("windAlt")?.value, null);
        const dir = safeFloat(document.getElementById("windDirFrom")?.value, null);
        const spd = safeFloat(document.getElementById("windSpd")?.value, null);
        if (alt == null || dir == null || spd == null) { showSnackbar("Wind: Werte fehlen."); return; }
        addWindLayer({ altM: alt, fromDeg: dir, speedKmh: spd, ts: now(), source: "manual" });
      });
      document.getElementById("btnClearWind")?.addEventListener("click", () => {
        STATE.wind.layers = [];
        persistAll();
        updateWindPanel();
        updateWindHud();
        updateNavToast();
        showSnackbar("Wind gelöscht.");
      });

      // Setup
      const tglSim = document.getElementById("tglSim");
      const knobSim = document.getElementById("tglSimKnob");
      if (tglSim && knobSim) setToggleUI(tglSim, knobSim, STATE.sim.enabled);
      tglSim?.addEventListener("change", (e) => {
        if (tglSim && knobSim) setToggleUI(tglSim, knobSim, e.target.checked);
        initSimulationToggle(e.target.checked);
      });

      document.getElementById("btnWakeLock")?.addEventListener("click", requestWakeLock);
      document.getElementById("btnReset")?.addEventListener("click", () => {
        STATE.ui.followGps = true;
        STATE.ui.windHudOpen = false;
        updateFollowToggleUi();
        updateWindHud();
        showSnackbar("UI zurückgesetzt.");
        persistAll();
      });

      document.getElementById("kmlFile")?.addEventListener("change", (e) => {
        const f = e.target.files?.[0];
        importKmlFile(f);
      });

      // Archive
      document.getElementById("btnClearArchive")?.addEventListener("click", () => {
        STATE.flight.archive = [];
        persistAll();
        updateArchivePanel();
        showSnackbar("Archiv gelöscht.");
      });

      // Sim controls (press & hold)
      const burner = document.getElementById("btnBurner");
      const vent = document.getElementById("btnVent");

      const press = (el, onDown, onUp) => {
        if (!el) return;
        el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); onDown(true); });
        el.addEventListener("pointerup",   (e)=>{ e.preventDefault(); onUp(false); });
        el.addEventListener("pointercancel",(e)=>{ e.preventDefault(); onUp(false); });
        el.addEventListener("pointerleave",(e)=>{ onUp(false); });
      };
      press(burner, handleBurner, handleBurner);
      press(vent, handleVent, handleVent);

      // WakeLock reacquire
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && STATE.ui.wakeLock) {
          requestWakeLock();
        }
      });

      // Start GPS unless simulation
      if (STATE.sim.enabled) {
        initSimulationToggle(true);
      } else {
        initGPS();
      }

      // Final UI pass
      updateButtons();
      updateGpsBadge();
      updateNavToast();
      updateWindPanel();
      updateArchivePanel();
    };
  </script>
</body>
</html>
