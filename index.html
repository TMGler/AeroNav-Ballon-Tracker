<!DOCTYPE html>
<html lang="de" class="h-full bg-slate-950">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#020617" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="CompNavAir" />
  <title>CompNavAir</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet Omnivore (KML import) -->
  <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

  <!-- FontAwesome (UI Icons only) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; }
    .no-select { user-select: none; -webkit-user-select: none; }
    .safe-bottom { padding-bottom: calc(env(safe-area-inset-bottom) + 0px); }
    .safe-top { padding-top: env(safe-area-inset-top); }
    #map { height: 100%; width: 100%; }
    .leaflet-container { background: #0b1220; }
    .btn-touch { touch-action: manipulation; }
    .shadow-soft { box-shadow: 0 12px 30px rgba(0,0,0,.35); }
    .panel-scroll { max-height: calc(100vh - 7.5rem); overflow: auto; -webkit-overflow-scrolling: touch; }
    .mono { font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1; }
    .leaflet-control-container { z-index: 10; }

    .wp-x {
      width: 22px; height: 22px;
      display: grid; place-items: center;
      border-radius: 9999px;
      background: rgba(2,6,23,.75);
      border: 2px solid rgba(251,191,36,.95);
      color: rgba(251,191,36,.95);
      font-weight: 900;
      font-size: 14px;
      line-height: 1;
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      pointer-events: none;
    }

    /* footer marker strip */
    .marker-strip { overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .marker-strip::-webkit-scrollbar { height: 6px; }
    .marker-strip::-webkit-scrollbar-thumb { background: rgba(148,163,184,.35); border-radius: 9999px; }
  </style>
</head>

<body class="h-full text-slate-100">
  <div id="app" class="h-full w-full flex flex-col bg-slate-950">
    <!-- Header -->
    <header class="safe-top z-40 bg-slate-950/90 backdrop-blur border-b border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex items-center gap-2 min-w-0">
          <div class="w-9 h-9 rounded-2xl bg-slate-900 border border-slate-800 grid place-items-center">
            <i class="fa-solid fa-balloon text-sky-300"></i>
          </div>
          <div class="min-w-0">
            <div class="font-extrabold leading-5 truncate">CompNavAir</div>
            <div class="text-xs text-slate-400 leading-4 truncate">
              <span id="gpsBadge" class="inline-flex items-center gap-1">
                <span id="gpsDot" class="w-2 h-2 rounded-full bg-slate-500 inline-block"></span>
                <span id="gpsText">GPS: –</span>
              </span>
              <span class="mx-2 text-slate-600">•</span>
              <span id="modeText">LIVE</span>
              <span class="mx-2 text-slate-600">•</span>
              <span id="briefingHeaderBadge" class="hidden text-amber-300 font-bold truncate">Briefing: –</span>
            </div>
          </div>
        </div>

        <div class="ml-auto flex items-center gap-2">
          <button id="btnStartFlight" class="btn-touch h-10 px-3 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-play mr-2"></i>Start
          </button>
          <button id="btnFinish" class="btn-touch hidden h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-flag-checkered mr-2"></i>Fertig
          </button>

          <button id="btnWindHud" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-wind text-slate-200"></i>
          </button>

          <button id="btnMapSettings" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-layer-group text-slate-200"></i>
          </button>

          <button id="btnCenter" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-location-crosshairs text-slate-200"></i>
          </button>

          <button id="btnMenu" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-bars text-slate-200"></i>
          </button>
        </div>
      </div>
    </header>

    <!-- Main -->
    <main class="relative flex-1 min-h-0">
      <div id="map" class="absolute inset-0 z-0"></div>

      <!-- Wind HUD -->
      <div id="windHud" class="hidden absolute left-3 top-3 z-50 w-[86vw] max-w-[360px] rounded-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft">
        <div class="px-3 py-2 flex items-center gap-2 border-b border-slate-800">
          <div class="font-bold"><i class="fa-solid fa-wind mr-2 text-sky-300"></i>Wind HUD</div>
          <div class="ml-auto flex items-center gap-2">
            <button id="btnWindFetch" class="btn-touch px-3 h-9 rounded-xl bg-sky-400 text-slate-950 font-extrabold text-sm hover:bg-sky-300 active:bg-sky-500">
              <i class="fa-solid fa-cloud-arrow-down mr-2"></i>Online
            </button>
            <button id="btnWindClose" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
        </div>
        <div class="px-3 py-2">
          <div class="text-xs text-slate-400 mb-2">Schichten (Höhe / Richtung / Speed)</div>
          <div id="windHudList" class="space-y-2"></div>
        </div>
      </div>

      <!-- Nav Toast -->
      <div id="navToast" class="hidden absolute left-1/2 top-3 -translate-x-1/2 z-50 rounded-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft px-4 py-2 max-w-[92vw]">
        <div class="text-sm font-bold truncate">
          <i id="navIcon" class="fa-solid fa-route mr-2 text-emerald-300"></i>
          <span id="navTitle">–</span>
        </div>
        <div class="text-xs text-slate-300 mt-0.5">
          <span class="mono" id="navLine1">–</span>
          <span class="mx-2 text-slate-600">•</span>
          <span id="navLine2">–</span>
        </div>
      </div>

      <!-- Simulation Controls -->
      <div id="simControls" class="hidden absolute left-3 top-24 z-50 flex flex-col gap-2">
        <button id="btnBurner" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-orange-400 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-fire-flame-curved mr-2"></i>AUF
        </button>
        <button id="btnVent" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-sky-300 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-arrow-down-wide-short mr-2"></i>AB
        </button>
      </div>

      <!-- Map Settings Modal -->
      <div id="mapModal" class="hidden absolute inset-0 z-50">
        <div id="mapModalBg" class="absolute inset-0 bg-black/60"></div>
        <div class="absolute left-1/2 top-24 -translate-x-1/2 w-[92vw] max-w-[420px] rounded-2xl bg-slate-950 border border-slate-800 shadow-soft">
          <div class="px-4 py-3 flex items-center border-b border-slate-800">
            <div class="font-extrabold"><i class="fa-solid fa-layer-group mr-2 text-sky-300"></i>Karte</div>
            <button id="btnMapModalClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
          <div class="p-4 space-y-3">
            <div class="grid grid-cols-2 gap-2">
              <button id="btnBaseOSM" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-map mr-2"></i>OSM
              </button>
              <button id="btnBaseSAT" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-satellite mr-2"></i>Sat
              </button>
            </div>
            <div class="flex items-center justify-between rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">GPS Follow</div>
                <div class="text-xs text-slate-400">Wenn du die Karte ziehst, wird Follow automatisch aus.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglFollow" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglFollowKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>
          </div>
        </div>
      </div>

      <!-- Snackbar -->
      <div id="snackbar" class="hidden absolute left-1/2 bottom-24 -translate-x-1/2 z-50 max-w-[92vw] rounded-2xl bg-slate-950/90 border border-slate-800 shadow-soft px-4 py-2 text-sm"></div>
    </main>

    <!-- Footer Cockpit -->
    <footer class="safe-bottom z-40 bg-slate-950/95 backdrop-blur border-t border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex-1 grid grid-cols-3 gap-2">
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">GS</div>
            <div class="text-lg font-extrabold mono"><span id="instGS">–</span> <span class="text-xs font-bold text-slate-400">km/h</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">ALT</div>
            <div class="text-lg font-extrabold mono"><span id="instALT">–</span> <span class="text-xs font-bold text-slate-400">m</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">VARIO</div>
            <div class="text-lg font-extrabold mono"><span id="instVAR">–</span> <span class="text-xs font-bold text-slate-400">m/s</span></div>
          </div>
        </div>

        <!-- Marker strip (dynamic) -->
        <div class="marker-strip flex items-center gap-2 w-[44vw] max-w-[520px]">
          <div id="markerStrip" class="flex items-center gap-2"></div>
        </div>
      </div>
    </footer>
  </div>

  <!-- Side Drawer -->
  <div id="drawerWrap" class="hidden fixed inset-0 z-[70]">
    <div id="drawerBg" class="absolute inset-0 bg-black/60"></div>
    <aside id="drawer" class="absolute right-0 top-0 h-full w-[92vw] max-w-[420px] bg-slate-950 border-l border-slate-800 shadow-soft flex flex-col">
      <div class="safe-top px-4 py-3 flex items-center border-b border-slate-800">
        <div class="font-extrabold"><i class="fa-solid fa-compass mr-2 text-sky-300"></i>Menü</div>
        <button id="btnDrawerClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="px-3 py-2 border-b border-slate-800">
        <div class="grid grid-cols-4 gap-2">
          <button data-tab="task" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Task</button>
          <button data-tab="wind" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Wind</button>
          <button data-tab="setup" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Setup</button>
          <button data-tab="archive" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Archiv</button>
        </div>
      </div>

      <div class="px-4 py-3 panel-scroll">
        <!-- TASK -->
        <section id="tab_task" class="space-y-4">

          <!-- Briefing Builder -->
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-clipboard-list mr-2 text-amber-300"></i>Briefing (Planung)</div>

            <div class="grid grid-cols-1 gap-2">
              <label class="text-xs text-slate-400">Briefing auswählen</label>
              <select id="briefingSelect" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 font-bold"></select>
            </div>

            <div class="mt-2 grid grid-cols-2 gap-2">
              <button id="btnBriefNew" class="btn-touch h-11 rounded-xl bg-amber-300 hover:bg-amber-200 active:bg-amber-400 text-slate-950 font-extrabold">
                <i class="fa-solid fa-plus mr-2"></i>Neu
              </button>
              <button id="btnBriefDup" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-clone mr-2"></i>Dupl.
              </button>
            </div>

            <div class="mt-2 grid grid-cols-2 gap-2">
              <button id="btnBriefSave" class="btn-touch h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-floppy-disk mr-2"></i>Speichern
              </button>
              <button id="btnBriefDelete" class="btn-touch h-11 rounded-xl bg-rose-500 hover:bg-rose-400 active:bg-rose-600 text-slate-950 font-extrabold">
                <i class="fa-solid fa-trash mr-2"></i>Löschen
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3 space-y-2">
              <div>
                <div class="text-xs text-slate-400 mb-1">Titel</div>
                <input id="briefTitle" type="text" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="z.B. German Cup Abendfahrt" />
              </div>

              <div class="grid grid-cols-2 gap-2">
                <div>
                  <div class="text-xs text-slate-400 mb-1">Startperiode von</div>
                  <input id="briefStartFrom" type="time" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" />
                </div>
                <div>
                  <div class="text-xs text-slate-400 mb-1">Startperiode bis</div>
                  <input id="briefStartTo" type="time" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" />
                </div>
              </div>

              <div>
                <div class="text-xs text-slate-400 mb-1">Wertungsende</div>
                <input id="briefScoringEnd" type="time" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" />
              </div>

              <div class="flex items-center justify-between rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
                <div>
                  <div class="font-bold">Task-Reihenfolge</div>
                  <div class="text-xs text-slate-400">Fix (nacheinander) oder frei wählbar.</div>
                </div>
                <select id="briefOrderMode" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 font-bold text-sm">
                  <option value="fixed">Fix</option>
                  <option value="free">Frei</option>
                </select>
              </div>

              <div class="mt-2 grid grid-cols-2 gap-2">
                <button id="btnBriefActivate" class="btn-touch h-11 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold">
                  <i class="fa-solid fa-bolt mr-2"></i>Aktivieren
                </button>
                <button id="btnBriefDeactivate" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                  <i class="fa-solid fa-circle-xmark mr-2"></i>Deaktiv.
                </button>
              </div>

              <div class="text-xs text-slate-400 mt-2">
                Aktiviertes Briefing steuert die Task-Abarbeitung in der Fahrt. Marker-Buttons unten werden daraus generiert.
              </div>
            </div>
          </div>

          <!-- Task Editor (single task form) -->
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-flag mr-2 text-emerald-300"></i>Task Editor (für Briefing)</div>

            <label class="text-xs text-slate-400">Task-Typ</label>
            <select id="taskType" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 font-bold"></select>

            <label class="text-xs text-slate-400 mt-3 block">Task-Titel (optional)</label>
            <input id="taskTitle" type="text" placeholder="z.B. JDG Zielkreuz Dorf" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3" />

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="flex items-center justify-between">
                <div>
                  <div class="font-bold">Marker-Anzahl</div>
                  <div class="text-xs text-slate-400">Wird aus Task abgeleitet, kann aber angepasst werden.</div>
                </div>
                <input id="taskMarkerCount" type="number" min="0" max="6" class="h-10 w-20 rounded-xl bg-slate-950 border border-slate-700 px-3 mono font-extrabold text-center" value="1" />
              </div>

              <div class="mt-3">
                <div class="text-xs text-slate-400 mb-2">Marker-Farben (frei wählbar)</div>
                <div id="taskMarkerColors" class="grid grid-cols-3 gap-2"></div>
              </div>
            </div>

            <div id="taskFields" class="mt-3 space-y-3"></div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnAddTaskToBrief" class="btn-touch h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-plus mr-2"></i>In Briefing
              </button>
              <button id="btnClearTaskForm" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-eraser mr-2"></i>Reset
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold text-sm mb-1"><i class="fa-solid fa-hand-pointer mr-2 text-sky-300"></i>Karte tippen</div>
              <div id="mapPickHint" class="hidden text-xs text-amber-300">
                Tippe auf die Karte, um Punkt A zu setzen (Briefing).
              </div>
              <div class="text-xs text-slate-400 mt-2">
                Tipp: <span class="font-bold">Langer Klick</span> auf die Karte erstellt einen <span class="font-bold">freien Waypoint</span> (ohne Task).
              </div>
            </div>
          </div>

          <!-- Briefing Task List -->
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="flex items-center gap-2">
              <div class="font-extrabold"><i class="fa-solid fa-list-check mr-2 text-sky-300"></i>Tasks im Briefing</div>
              <div class="ml-auto text-xs text-slate-400" id="briefTaskCount">0</div>
            </div>

            <div id="briefTasksList" class="mt-3 space-y-2"></div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnUseSelectedTask" class="btn-touch h-11 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-location-dot mr-2"></i>Task aktiv
              </button>
              <button id="btnClearActiveTask" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-ban mr-2"></i>Kein Task
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold text-sm mb-1"><i class="fa-solid fa-route mr-2 text-emerald-300"></i>Abarbeitung</div>
              <div class="text-xs text-slate-400">
                Modus „Fix“: nur „Nächster Task“ erlaubt. Modus „Frei“: jeden Task anwählbar.
              </div>
              <button id="btnNextTask" class="btn-touch mt-2 w-full h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-forward-step mr-2"></i>Nächster Task
              </button>
            </div>
          </div>

          <!-- Waypoint helper -->
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-diagram-project mr-2 text-sky-300"></i>ELB Helper</div>
            <div class="text-xs text-slate-400 mb-3">Nur während aktiver Fahrt.</div>
            <div class="grid grid-cols-3 gap-2">
              <button id="btnSetA" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set A</button>
              <button id="btnSetB" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set B</button>
              <button id="btnSetC" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set C</button>
            </div>
            <div class="mt-3 text-sm">
              <div class="text-xs text-slate-400">ELB Ergebnis (°):</div>
              <div class="font-extrabold mono text-lg" id="elbowResult">–</div>
            </div>
          </div>
        </section>

        <!-- WIND -->
        <section id="tab_wind" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-wind mr-2 text-sky-300"></i>Windprofil</div>
            <div class="text-xs text-slate-400 mb-3">Auto-Record nur während Fahrt.</div>

            <div class="grid grid-cols-3 gap-2">
              <input id="windAlt" type="number" placeholder="Höhe m" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
              <input id="windDirFrom" type="number" placeholder="Richtung FROM °" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
              <input id="windSpd" type="number" placeholder="Speed km/h" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
            </div>
            <div class="mt-2 grid grid-cols-2 gap-2">
              <button id="btnAddWind" class="btn-touch h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-plus mr-2"></i>Hinzufügen
              </button>
              <button id="btnClearWind" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-trash mr-2"></i>Alle löschen
              </button>
            </div>

            <div class="mt-3 space-y-2" id="windList"></div>
          </div>
        </section>

        <!-- SETUP -->
        <section id="tab_setup" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-gear mr-2 text-sky-300"></i>Setup</div>

            <div class="flex items-center justify-between rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">Simulation</div>
                <div class="text-xs text-slate-400">GPS wird pausiert. Drift basiert auf Windprofil.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglSim" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglSimKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnWakeLock" class="btn-touch h-11 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-mobile-screen mr-2"></i>WakeLock
              </button>
              <button id="btnResetUi" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-rotate mr-2"></i>Reset UI
              </button>
            </div>

            <div class="mt-3 grid grid-cols-1 gap-2">
              <button id="btnClearWaypoint" class="btn-touch h-11 w-full rounded-xl bg-amber-300 hover:bg-amber-200 active:bg-amber-400 text-slate-950 font-extrabold">
                <i class="fa-solid fa-xmark mr-2"></i>Waypoint löschen
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-file-import mr-2 text-emerald-300"></i>KML Import</div>
              <input id="kmlFile" type="file" accept=".kml,.xml" class="block w-full text-sm text-slate-300 file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-bold file:bg-slate-900 file:text-slate-200 hover:file:bg-slate-800" />
              <div class="text-xs text-slate-400 mt-2">Importiertes KML wird als Overlay dargestellt (nur Ansicht).</div>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-download mr-2 text-amber-300"></i>PWA Hinweis</div>
              <div class="text-xs text-slate-400">
                Für „ohne Browser“-Look: im Chrome-Menü „Zum Startbildschirm hinzufügen“ → App öffnen.
              </div>
            </div>
          </div>
        </section>

        <!-- ARCHIVE -->
        <section id="tab_archive" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-box-archive mr-2 text-sky-300"></i>Archiv</div>
            <div class="text-xs text-slate-400 mb-3">Beendete Fahrten + KML Export (Track + Marker).</div>
            <div id="archiveList" class="space-y-2"></div>
            <button id="btnClearArchive" class="btn-touch mt-3 w-full h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
              <i class="fa-solid fa-trash mr-2"></i>Archiv löschen
            </button>
          </div>
        </section>
      </div>
    </aside>
  </div>

  <script>
    /********************************************************************
     * 1) KONSTANTEN & KONFIGURATION
     ********************************************************************/
    const APP = {
      name: "CompNavAir",
      version: "1.3.0-briefing",
      defaultCenter: { lat: 49.317, lon: 8.448 },
      defaultZoom: 13,
      storageKey: "compnavair_v1_3",
      maxTrackPoints: 20000,
      trackMinDistM: 8,
      maxGpsJumpM: 160,
      gpsSmoothingAlpha: 0.25,
      followPanMinMs: 800,
      longPressMs: 650,
      longPressMovePx: 10,
      maxMarkerButtons: 6, // UI cap
    };

    const TILE = {
      osm: { url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", attr: '&copy; OpenStreetMap-Mitwirkende' },
      esri:{ url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", attr: "Tiles &copy; Esri" }
    };

    const CIA_TASKS = [
      { num: "15.1",  code: "PDG", title: "SELBST GEWÄHLTES ZIEL" },
      { num: "15.2",  code: "JDG", title: "VORGEGEBENES ZIEL" },
      { num: "15.3",  code: "HWZ", title: "QUAL DER WAHL" },
      { num: "15.4",  code: "FIN", title: "FLY IN" },
      { num: "15.5",  code: "FON", title: "FLY ON" },
      { num: "15.6",  code: "HNH", title: "FUCHSJAGD" },
      { num: "15.7",  code: "WSD", title: "FUCHSJAGD MIT ANLAUF" },
      { num: "15.8",  code: "GBM", title: "GORDON BENNETT MEMORIAL" },
      { num: "15.9",  code: "CRT", title: "ZIELFAHRT MIT ZEITFENSTER" },
      { num: "15.10", code: "RTA", title: "RENNEN ZUM WERTUNGSGEBIET" },
      { num: "15.11", code: "ELB", title: "ELLENBOGEN" },
      { num: "15.12", code: "LRN", title: "DREIECKSFLÄCHE" },
      { num: "15.13", code: "MDT", title: "MINIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.14", code: "SFL", title: "MINIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.15", code: "MDD", title: "MINIMUM DISTANCE ZWEI MARKER" },
      { num: "15.16", code: "XDT", title: "MAXIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.17", code: "XDI", title: "MAXIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.18", code: "XDD", title: "MAXIMUM DISTANCE ZWEI MARKER" },
      { num: "15.19", code: "ANG", title: "WINKEL" },
      { num: "15.20", code: "3DT", title: "3D-AUFGABE" },
      { num: "15.21", code: "APT", title: "HÖHENPROFIL-AUFGABE" },
    ];

    // Default Marker Count by task nature (can be overridden per task)
    // 0 = track-only / no marker, 1 = single, 2 = two markers
    const TASK_DEFAULTS = {
      PDG: { markerCount: 1 },
      JDG: { markerCount: 1 },
      HWZ: { markerCount: 1 },
      FIN: { markerCount: 1 },
      FON: { markerCount: 1 },
      HNH: { markerCount: 1 },
      WSD: { markerCount: 1 },
      GBM: { markerCount: 1 },
      CRT: { markerCount: 1 },
      RTA: { markerCount: 0 }, // often trackpoint possible
      ELB: { markerCount: 0 },
      LRN: { markerCount: 0 },
      MDT: { markerCount: 1 },
      SFL: { markerCount: 1 },
      MDD: { markerCount: 2 },
      XDT: { markerCount: 1 },
      XDI: { markerCount: 1 },
      XDD: { markerCount: 2 },
      ANG: { markerCount: 0 },
      "3DT": { markerCount: 0 },
      APT: { markerCount: 0 },
    };

    const COLOR_HEX = {
      pink:"#fb7185", amber:"#fbbf24", emerald:"#34d399", sky:"#38bdf8",
      violet:"#a78bfa", rose:"#f43f5e", lime:"#a3e635", orange:"#fb923c",
      slate:"#94a3b8"
    };
    const DEFAULT_MARKER_COLOR_SET = ["#fb7185","#fbbf24","#34d399","#38bdf8","#a78bfa","#f43f5e"];

    /********************************************************************
     * 2) GLOBALE VARIABLEN (STATE)
     ********************************************************************/
    const STATE = {
      map: null,
      layers: {
        baseOSM: null,
        baseSAT: null,
        tasksLayer: null,
        trackLayer: null,
        markersLayer: null,
        pickLayer: null,
        waypointLayer: null,
        trajectoryLayer: null,
        kmlLayer: null,
        trackLine: null,
      },
      ui: {
        drawerOpen: false,
        drawerTab: "task",
        followGps: true,
        base: "osm",
        windHudOpen: false,

        mapPickMode: false,
        mapPickWhich: "A",
        pickMarkers: { A:null, B:null, C:null },

        snackbarTimer: null,
        wakeLock: null,
        mapUserInteracting: false,

        longPress: {
          active: false,
          timer: null,
          pointerId: null,
          startX: 0,
          startY: 0,
          startLatLng: null,
        },

        // briefing UI state
        selectedBriefingId: null,
        selectedBriefTaskId: null,
      },
      gps: {
        watchId: null,
        hasFix: false,
        fixTs: 0,
        lat: null,
        lon: null,
        altM: null,
        speedKmh: 0,
        headingDeg: null,
        accuracyM: null,
        smoothLat: null,
        smoothLon: null,
        lastAltM: null,
        lastAltTs: null,
        lastPanTs: 0,
        lastCourseDeg: null,
      },
      sim: {
        enabled: false,
        running: false,
        lat: null,
        lon: null,
        altM: 180,
        headingDeg: 0,
        speedKmh: 0,
        vRateMps: 0,
        timer: null,
        lastTickTs: 0,
      },
      flight: {
        active: false,
        title: "",
        startedTs: 0,
        track: [],
        markers: [],
        archive: [],

        // briefing-run runtime:
        briefingRun: null, // { briefingId, taskStates: [{taskId, usedMarkers:boolean[], startedTs, finishedTs}], activeTaskId }
      },
      wind: {
        layers: [],
        lastAuto: { altM: null, courseDeg: null, ts: 0 },
      },
      task: {
        active: null, // active task overlay / navigation target (from briefing or standalone)
        pointsABC: { A:null, B:null, C:null },
        apt: { startTs: null },
      },
      waypoint: {
        active: null,
      },
      balloon: {
        marker: null,
        el: null,
      },

      // Briefings storage
      briefings: {
        list: [],             // array of briefing objects
        activeId: null,       // briefing currently activated for flight usage
      },
    };

    /********************************************************************
     * 3) HELFER-FUNKTIONEN (Math, Formatting)
     ********************************************************************/
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function now() { return Date.now(); }
    function toRad(deg) { return deg * Math.PI / 180; }
    function toDeg(rad) { return rad * 180 / Math.PI; }

    function haversineM(a, b) {
      const R = 6371000;
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(s), Math.sqrt(1-s));
    }

    function bearingDeg(a, b) {
      const lat1 = toRad(a.lat), lat2 = toRad(a.lat + (b.lat-a.lat));
      const dLon = toRad(b.lon - a.lon);
      const y = Math.sin(dLon) * Math.cos(toRad(b.lat));
      const x = Math.cos(toRad(a.lat))*Math.sin(toRad(b.lat)) - Math.sin(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }

    function destPoint(a, bearingDegVal, distM) {
      const R = 6371000;
      const brng = toRad(bearingDegVal);
      const lat1 = toRad(a.lat);
      const lon1 = toRad(a.lon);
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(distM/R) + Math.cos(lat1)*Math.sin(distM/R)*Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(distM/R)*Math.cos(lat1), Math.cos(distM/R)-Math.sin(lat1)*Math.sin(lat2));
      return { lat: toDeg(lat2), lon: ((toDeg(lon2)+540)%360)-180 };
    }

    function angDiffDeg(a, b) {
      let d = ((a - b + 540) % 360) - 180;
      return Math.abs(d);
    }

    function fmtDist(m) {
      if (m == null || !isFinite(m)) return "–";
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m/1000).toFixed(2)} km`;
    }

    function fmtNum(n, digits=0) {
      if (n == null || !isFinite(n)) return "–";
      return n.toFixed(digits);
    }

    function fmtTime(sec) {
      if (sec == null || !isFinite(sec) || sec < 0) return "–";
      const s = Math.round(sec);
      const m = Math.floor(s / 60);
      const r = s % 60;
      if (m < 60) return `${String(m).padStart(2,"0")}:${String(r).padStart(2,"0")}`;
      const h = Math.floor(m / 60);
      const mm = m % 60;
      return `${h}:${String(mm).padStart(2,"0")}:${String(r).padStart(2,"0")}`;
    }

    function safeFloat(v, fallback=null) {
      const n = parseFloat(String(v ?? "").replace(",", "."));
      return Number.isFinite(n) ? n : fallback;
    }

    function smooth(prev, next, alpha) {
      if (prev == null || !isFinite(prev)) return next;
      return prev + alpha * (next - prev);
    }

    function uid() { return Math.random().toString(36).slice(2, 10); }

    function escapeXml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&apos;");
    }

    function showSnackbar(msg, ms=2200) {
      const el = document.getElementById("snackbar");
      if (!el) return;
      el.textContent = msg;
      el.classList.remove("hidden");
      clearTimeout(STATE.ui.snackbarTimer);
      STATE.ui.snackbarTimer = setTimeout(() => el.classList.add("hidden"), ms);
    }

    function setToggleUI(inputEl, knobEl, on) {
      inputEl.checked = !!on;
      knobEl.style.left = on ? "1.6rem" : "0.25rem";
      knobEl.style.background = on ? "#34d399" : "#e2e8f0";
    }

    function getCurrentPos() {
      if (STATE.sim.enabled && STATE.sim.lat != null && STATE.sim.lon != null) return { lat: STATE.sim.lat, lon: STATE.sim.lon };
      if (!STATE.gps.hasFix || STATE.gps.lat == null || STATE.gps.lon == null) return null;
      return { lat: STATE.gps.lat, lon: STATE.gps.lon };
    }

    function getCurrentAltM() {
      if (STATE.sim.enabled) return STATE.sim.altM;
      return STATE.gps.altM;
    }

    function getGroundSpeedMps() {
      const kmh = STATE.sim.enabled ? (STATE.sim.speedKmh || 0) : (STATE.gps.speedKmh || 0);
      return Math.max(0, kmh) / 3.6;
    }

    function getCourseDeg() {
      if (STATE.sim.enabled) return (STATE.sim.headingDeg ?? 0);
      const h = STATE.gps.headingDeg;
      const gs = STATE.gps.speedKmh || 0;
      if (h != null && isFinite(h) && gs >= 3) return ((h % 360) + 360) % 360;
      if (STATE.gps.lastCourseDeg != null) return STATE.gps.lastCourseDeg;
      return 0;
    }

    function hashStr(s) {
      let h = 0;
      for (let i=0;i<s.length;i++) h = ((h<<5)-h) + s.charCodeAt(i) | 0;
      return h;
    }

    function windToDegFrom(fromDeg) { return (fromDeg + 180) % 360; }

    function defaultMarkerCountForTask(code) {
      return TASK_DEFAULTS[code]?.markerCount ?? 1;
    }

    function defaultMarkerColors(count) {
      const arr = [];
      for (let i=0;i<count;i++) arr.push(DEFAULT_MARKER_COLOR_SET[i % DEFAULT_MARKER_COLOR_SET.length]);
      return arr;
    }

    function ensureMarkerColorsArray(task, count) {
      const out = Array.isArray(task.markerColors) ? task.markerColors.slice(0) : [];
      while (out.length < count) out.push(DEFAULT_MARKER_COLOR_SET[out.length % DEFAULT_MARKER_COLOR_SET.length]);
      return out.slice(0, count);
    }

    function getActiveBriefing() {
      if (!STATE.briefings.activeId) return null;
      return STATE.briefings.list.find(b => b.id === STATE.briefings.activeId) || null;
    }

    function getSelectedBriefing() {
      if (!STATE.ui.selectedBriefingId) return null;
      return STATE.briefings.list.find(b => b.id === STATE.ui.selectedBriefingId) || null;
    }

    function getBriefTask(briefing, taskId) {
      if (!briefing || !taskId) return null;
      return (briefing.tasks || []).find(t => t.id === taskId) || null;
    }

    /********************************************************************
     * 4) UI-RENDER-FUNKTIONEN
     ********************************************************************/
    function updateGpsBadge() {
      const dot = document.getElementById("gpsDot");
      const txt = document.getElementById("gpsText");
      const mode = document.getElementById("modeText");
      if (!dot || !txt || !mode) return;

      if (STATE.sim.enabled) {
        dot.className = "w-2 h-2 rounded-full bg-amber-300 inline-block";
        txt.textContent = "SIM";
        mode.textContent = "SIM";
        return;
      }

      if (STATE.gps.hasFix) {
        dot.className = "w-2 h-2 rounded-full bg-emerald-400 inline-block";
        const acc = STATE.gps.accuracyM != null ? `±${Math.round(STATE.gps.accuracyM)}m` : "";
        txt.textContent = `GPS: OK ${acc}`.trim();
        mode.textContent = "LIVE";
      } else {
        dot.className = "w-2 h-2 rounded-full bg-slate-500 inline-block";
        txt.textContent = "GPS: –";
        mode.textContent = "LIVE";
      }
    }

    function updateBriefingHeaderBadge() {
      const el = document.getElementById("briefingHeaderBadge");
      if (!el) return;
      const b = getActiveBriefing();
      if (!b) { el.classList.add("hidden"); el.textContent = "Briefing: –"; return; }
      el.classList.remove("hidden");
      el.textContent = `Briefing: ${b.title || "–"}`;
    }

    function updateButtons() {
      document.getElementById("btnStartFlight")?.classList.toggle("hidden", STATE.flight.active);
      document.getElementById("btnFinish")?.classList.toggle("hidden", !STATE.flight.active);
      document.getElementById("simControls")?.classList.toggle("hidden", !STATE.sim.enabled);

      const showNav = !!STATE.task.active || !!STATE.waypoint?.active;
      document.getElementById("navToast")?.classList.toggle("hidden", !showNav);

      updateBriefingHeaderBadge();
      renderMarkerStrip();
    }

    function updateInstruments() {
      const gsEl = document.getElementById("instGS");
      const altEl = document.getElementById("instALT");
      const varEl = document.getElementById("instVAR");

      let gs = 0, alt = null, vario = null;

      if (STATE.sim.enabled) {
        gs = STATE.sim.speedKmh || 0;
        alt = STATE.sim.altM;
        vario = STATE.sim.vRateMps;
      } else {
        gs = STATE.gps.speedKmh || 0;
        alt = STATE.gps.altM;
        vario = calcVarioMps();
      }

      if (gsEl) gsEl.textContent = fmtNum(gs, 1);
      if (altEl) altEl.textContent = alt == null ? "–" : String(Math.round(alt));
      if (varEl) varEl.textContent = vario == null ? "–" : fmtNum(vario, 1);
    }

    function calcVarioMps() {
      const alt = STATE.gps.altM;
      const ts = now();
      if (alt == null || !isFinite(alt)) return null;

      if (STATE.gps.lastAltM == null) {
        STATE.gps.lastAltM = alt;
        STATE.gps.lastAltTs = ts;
        return 0;
      }
      const dt = (ts - STATE.gps.lastAltTs) / 1000;
      if (dt < 0.6) return null;

      const da = alt - STATE.gps.lastAltM;
      STATE.gps.lastAltM = alt;
      STATE.gps.lastAltTs = ts;
      return da / dt;
    }

    function updateWindHud() {
      const box = document.getElementById("windHud");
      const list = document.getElementById("windHudList");
      if (!box || !list) return;

      box.classList.toggle("hidden", !STATE.ui.windHudOpen);

      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM).slice(0, 10);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Keine Winddaten.</div>`;
        return;
      }

      list.innerHTML = items.map(w => {
        const to = windToDegFrom(w.fromDeg);
        return `
          <div class="flex items-center justify-between rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="min-w-0">
              <div class="font-extrabold mono">${Math.round(w.altM)} m</div>
              <div class="text-xs text-slate-400 truncate">${escapeXml(w.source || "manual")} • ${new Date(w.ts).toLocaleTimeString()}</div>
            </div>
            <div class="text-right">
              <div class="font-extrabold mono">${Math.round(w.fromDeg)}° <span class="text-xs text-slate-400">FROM</span></div>
              <div class="text-xs text-slate-300 mono">${fmtNum(w.speedKmh,1)} km/h → ${Math.round(to)}°</div>
            </div>
          </div>
        `;
      }).join("");
    }

    function updateNavToast() {
      const icon  = document.getElementById("navIcon");
      const title = document.getElementById("navTitle");
      const l1    = document.getElementById("navLine1");
      const l2    = document.getElementById("navLine2");
      if (!icon || !title || !l1 || !l2) return;

      const pos = getCurrentPos();
      const gsMps = getGroundSpeedMps();

      // Prefer task
      if (STATE.task.active) {
        icon.className = "fa-solid fa-route mr-2 text-emerald-300";
        const t = STATE.task.active;

        const run = STATE.flight.briefingRun;
        const b = getActiveBriefing();
        const activeLabel = (run && b) ? ` • ${getTaskProgressLabel(b, run, t.id)}` : "";

        title.textContent = `${t.code} — ${t.title || t.typeTitle}${activeLabel}`;

        const target = getPrimaryTarget(t);
        if (!pos || !target) {
          l1.textContent = "–";
          l2.textContent = !pos ? "Keine Position" : "Kein Ziel";
          return;
        }

        const d = haversineM(pos, target);
        l1.textContent = `Dist: ${fmtDist(d)}`;

        const rec = recommendLayerText(t, pos, target);
        l2.textContent = rec || "–";
        return;
      }

      // Waypoint
      if (STATE.waypoint?.active) {
        icon.className = "fa-solid fa-location-crosshairs mr-2 text-amber-300";
        title.textContent = "Waypoint";

        if (!pos) {
          l1.textContent = "–";
          l2.textContent = "Keine Position";
          return;
        }

        const wp = { lat: STATE.waypoint.active.lat, lon: STATE.waypoint.active.lon };
        const d = haversineM(pos, wp);
        const brg = bearingDeg(pos, wp);
        const ete = (gsMps > 0.6) ? (d / gsMps) : null;

        l1.textContent = `Dist: ${fmtDist(d)} • Brg: ${Math.round(brg)}°`;
        l2.textContent = `ETE: ${fmtTime(ete)}`;
        return;
      }

      document.getElementById("navToast")?.classList.add("hidden");
    }

    function renderBriefingSelect() {
      const sel = document.getElementById("briefingSelect");
      if (!sel) return;

      const list = STATE.briefings.list.slice(0);
      if (!list.length) {
        sel.innerHTML = `<option value="">(kein Briefing)</option>`;
        STATE.ui.selectedBriefingId = null;
        renderBriefingForm();
        renderBriefTasksList();
        return;
      }

      sel.innerHTML = list.map(b => `<option value="${b.id}">${escapeXml(b.title || "Briefing")} (${(b.tasks||[]).length} Tasks)</option>`).join("");
      if (!STATE.ui.selectedBriefingId || !list.some(b => b.id === STATE.ui.selectedBriefingId)) {
        STATE.ui.selectedBriefingId = list[0].id;
      }
      sel.value = STATE.ui.selectedBriefingId;

      renderBriefingForm();
      renderBriefTasksList();
    }

    function renderBriefingForm() {
      const b = getSelectedBriefing();
      const title = document.getElementById("briefTitle");
      const sf = document.getElementById("briefStartFrom");
      const st = document.getElementById("briefStartTo");
      const se = document.getElementById("briefScoringEnd");
      const om = document.getElementById("briefOrderMode");

      if (!title || !sf || !st || !se || !om) return;

      title.value = b?.title || "";
      sf.value = b?.startFrom || "";
      st.value = b?.startTo || "";
      se.value = b?.scoringEnd || "";
      om.value = b?.orderMode || "fixed";
    }

    function renderBriefTasksList() {
      const wrap = document.getElementById("briefTasksList");
      const cnt = document.getElementById("briefTaskCount");
      if (!wrap || !cnt) return;

      const b = getSelectedBriefing();
      const tasks = (b?.tasks || []);
      cnt.textContent = `${tasks.length}`;

      if (!b) {
        wrap.innerHTML = `<div class="text-sm text-slate-400">Lege zuerst ein Briefing an.</div>`;
        return;
      }
      if (!tasks.length) {
        wrap.innerHTML = `<div class="text-sm text-slate-400">Keine Tasks. Füge oben im Editor welche hinzu.</div>`;
        return;
      }

      const mode = b.orderMode || "fixed";
      const run = STATE.flight.briefingRun;
      const activeId = run?.activeTaskId || null;

      wrap.innerHTML = tasks.map((t, idx) => {
        const selected = STATE.ui.selectedBriefTaskId === t.id;
        const isActive = activeId === t.id;
        const mc = Math.min(APP.maxMarkerButtons, Math.max(0, t.markerCount ?? 0));
        const colorDots = (t.markerColors||[]).slice(0, mc).map(c => `<span class="inline-block w-3 h-3 rounded-full" style="background:${c}"></span>`).join("");

        const progress = (run && run.taskStates) ? getTaskProgressLabel(b, run, t.id) : "";

        return `
          <div class="rounded-2xl border ${selected ? "border-sky-400" : "border-slate-800"} bg-slate-950/60 p-3">
            <div class="flex items-center gap-2">
              <button data-sel="${t.id}" class="btn-touch flex-1 text-left">
                <div class="font-extrabold truncate">
                  ${idx+1}. ${escapeXml(t.code)} — ${escapeXml(t.title || t.typeTitle)}
                  ${progress ? `<span class="ml-2 text-xs text-amber-300 font-bold">${escapeXml(progress)}</span>` : ""}
                </div>
                <div class="text-xs text-slate-400 mt-0.5 truncate">
                  Marker: ${mc} <span class="mx-2 text-slate-600">•</span> ${colorDots || `<span class="text-slate-500">–</span>`}
                </div>
              </button>

              <div class="flex items-center gap-1">
                <button data-up="${t.id}" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="hoch">
                  <i class="fa-solid fa-arrow-up"></i>
                </button>
                <button data-down="${t.id}" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="runter">
                  <i class="fa-solid fa-arrow-down"></i>
                </button>
                <button data-del="${t.id}" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="löschen">
                  <i class="fa-solid fa-trash"></i>
                </button>
              </div>
            </div>

            <div class="mt-2 grid grid-cols-2 gap-2">
              <button data-activate="${t.id}" class="btn-touch h-10 rounded-xl ${isActive ? "bg-emerald-400 text-slate-950" : "bg-slate-900 border border-slate-800 hover:bg-slate-800"} font-extrabold text-sm">
                <i class="fa-solid fa-bullseye mr-2"></i>${isActive ? "Aktiv" : "Aktivieren"}
              </button>
              <button data-finish="${t.id}" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                <i class="fa-solid fa-check mr-2"></i>Done
              </button>
            </div>

            ${mode === "fixed" ? `<div class="text-[11px] text-slate-500 mt-2">Fix-Modus: Aktivierung folgt normalerweise der Reihenfolge.</div>` : ""}
          </div>
        `;
      }).join("");

      // wire
      wrap.querySelectorAll("[data-sel]").forEach(btn => {
        btn.addEventListener("click", () => {
          STATE.ui.selectedBriefTaskId = btn.getAttribute("data-sel");
          renderBriefTasksList();
        });
      });

      wrap.querySelectorAll("[data-del]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-del");
          deleteTaskFromBriefing(id);
        });
      });

      wrap.querySelectorAll("[data-up]").forEach(btn => {
        btn.addEventListener("click", () => moveTaskInBriefing(btn.getAttribute("data-up"), -1));
      });
      wrap.querySelectorAll("[data-down]").forEach(btn => {
        btn.addEventListener("click", () => moveTaskInBriefing(btn.getAttribute("data-down"), +1));
      });

      wrap.querySelectorAll("[data-activate]").forEach(btn => {
        btn.addEventListener("click", () => activateBriefingTask(btn.getAttribute("data-activate"), true));
      });

      wrap.querySelectorAll("[data-finish]").forEach(btn => {
        btn.addEventListener("click", () => markTaskDone(btn.getAttribute("data-finish")));
      });
    }

    function renderMarkerColorPickers(count, colors) {
      const wrap = document.getElementById("taskMarkerColors");
      if (!wrap) return;
      const c = Math.max(0, Math.min(APP.maxMarkerButtons, count));
      const arr = (colors && colors.length) ? colors.slice(0) : defaultMarkerColors(c);

      wrap.innerHTML = Array.from({length:c}).map((_, i) => `
        <div class="rounded-2xl bg-slate-950/70 border border-slate-800 p-2 flex items-center gap-2">
          <div class="text-xs font-extrabold text-slate-300">#${i+1}</div>
          <input data-mc="${i}" type="color" value="${arr[i] || DEFAULT_MARKER_COLOR_SET[i % DEFAULT_MARKER_COLOR_SET.length]}" class="h-10 w-full rounded-xl bg-slate-950 border border-slate-700 px-1" />
        </div>
      `).join("");
    }

    function renderMarkerStrip() {
      const wrap = document.getElementById("markerStrip");
      if (!wrap) return;

      // Determine markers from: active briefing+active task if flight active, else from currently active task (preview), else none.
      const run = STATE.flight.briefingRun;
      let task = null;
      let used = null;

      if (STATE.flight.active && run && run.activeTaskId) {
        const b = getActiveBriefing();
        const bt = getBriefTask(b, run.activeTaskId);
        if (bt) {
          task = bt;
          const st = run.taskStates?.find(s => s.taskId === bt.id);
          used = st?.usedMarkers || null;
        }
      } else if (STATE.task.active && STATE.task.active.markerCount != null) {
        // preview for briefing task activation
        task = STATE.task.active;
      }

      if (!task) {
        wrap.innerHTML = `
          <button id="btnMarkerFallback" class="btn-touch w-20 h-16 rounded-2xl bg-slate-700/60 border border-slate-800 text-slate-200 font-extrabold shadow-soft opacity-80">
            <i class="fa-solid fa-location-dot mr-2"></i>MARK
          </button>
        `;
        document.getElementById("btnMarkerFallback")?.addEventListener("click", () => showSnackbar("Kein Task aktiv (Briefing) – wähle einen Task oder setze Waypoint."));
        return;
      }

      const mc = Math.max(0, Math.min(APP.maxMarkerButtons, task.markerCount ?? 0));
      const colors = ensureMarkerColorsArray(task, mc);

      if (mc === 0) {
        wrap.innerHTML = `
          <div class="h-16 px-3 rounded-2xl bg-slate-900/60 border border-slate-800 flex items-center text-xs text-slate-400">
            <i class="fa-solid fa-ban mr-2"></i>Keine Marker für diesen Task
          </div>
        `;
        return;
      }

      wrap.innerHTML = colors.map((c, i) => {
        const isUsed = used ? !!used[i] : false;
        const label = isUsed ? "USED" : `M${i+1}`;
        const icon = isUsed ? "fa-check" : "fa-location-dot";
        return `
          <button data-mbtn="${i}" class="btn-touch w-20 h-16 rounded-2xl font-extrabold shadow-soft ${isUsed ? "opacity-40" : ""}"
                  style="background:${c};color:#0b1220;border:1px solid rgba(2,6,23,.35)">
            <i class="fa-solid ${icon} mr-2"></i>${label}
          </button>
        `;
      }).join("");

      wrap.querySelectorAll("[data-mbtn]").forEach(btn => {
        btn.addEventListener("click", () => {
          const idx = parseInt(btn.getAttribute("data-mbtn"), 10);
          if (!Number.isFinite(idx)) return;
          dropMarkerFromBriefingTask(idx);
        });
      });
    }

    function updateFollowToggleUi() {
      const tgl = document.getElementById("tglFollow");
      const knob = document.getElementById("tglFollowKnob");
      if (tgl && knob) setToggleUI(tgl, knob, STATE.ui.followGps);
    }

    function setMapPickHint(which, on) {
      const hint = document.getElementById("mapPickHint");
      if (!hint) return;
      hint.textContent = `Tippe auf die Karte, um Punkt ${which} zu setzen (Briefing).`;
      hint.classList.toggle("hidden", !on);
    }

    function openDrawer(open=true) {
      STATE.ui.drawerOpen = open;
      const wrap = document.getElementById("drawerWrap");
      if (!wrap) return;
      wrap.classList.toggle("hidden", !open);
      if (open) updateDrawerTabUi();
    }

    function updateDrawerTabUi() {
      document.querySelectorAll(".tabBtn").forEach(b => {
        const tab = b.getAttribute("data-tab");
        const on = tab === STATE.ui.drawerTab;
        b.classList.toggle("bg-sky-400", on);
        b.classList.toggle("text-slate-950", on);
        b.classList.toggle("border-sky-300", on);
      });
      ["task","wind","setup","archive"].forEach(t => {
        const el = document.getElementById(`tab_${t}`);
        if (el) el.classList.toggle("hidden", t !== STATE.ui.drawerTab);
      });
    }

    function openMapModal(open=true) {
      const modal = document.getElementById("mapModal");
      if (!modal) return;
      modal.classList.toggle("hidden", !open);
      updateFollowToggleUi();
    }

    /********************************************************************
     * 5) KERN-LOGIK (GPS, Map, Simulation, Tasks, Briefings)
     ********************************************************************/
    function initManifestAndSW() {
      try {
        const manifest = {
          name: "CompNavAir",
          short_name: "CompNavAir",
          start_url: ".",
          display: "standalone",
          background_color: "#020617",
          theme_color: "#020617",
          icons: []
        };
        const href = "data:application/manifest+json," + encodeURIComponent(JSON.stringify(manifest));
        const link = document.createElement("link");
        link.rel = "manifest";
        link.href = href;
        document.head.appendChild(link);
      } catch {}

      try {
        if (!("serviceWorker" in navigator)) return;
        const swCode = `
          self.addEventListener('install', (e)=>self.skipWaiting());
          self.addEventListener('activate', (e)=>self.clients.claim());
          self.addEventListener('fetch', (e)=>{});
        `;
        const blob = new Blob([swCode], { type: "text/javascript" });
        const url = URL.createObjectURL(blob);
        navigator.serviceWorker.register(url).catch(()=>{});
      } catch {}
    }

    function initMap() {
      const map = L.map("map", {
        zoomControl: true,
        attributionControl: true,
        zoomSnap: 0.25,
        preferCanvas: true,
      });
      STATE.map = map;

      STATE.layers.baseOSM = L.tileLayer(TILE.osm.url, { maxZoom: 19, attribution: TILE.osm.attr });
      STATE.layers.baseSAT = L.tileLayer(TILE.esri.url, { maxZoom: 19, attribution: TILE.esri.attr });
      STATE.layers.baseOSM.addTo(map);

      STATE.layers.tasksLayer = L.layerGroup().addTo(map);
      STATE.layers.trackLayer = L.layerGroup().addTo(map);
      STATE.layers.markersLayer = L.layerGroup().addTo(map);
      STATE.layers.pickLayer = L.layerGroup().addTo(map);
      STATE.layers.waypointLayer = L.layerGroup().addTo(map);
      STATE.layers.trajectoryLayer = L.layerGroup().addTo(map);

      STATE.layers.trackLine = L.polyline([], {
        color: "#ef4444",
        weight: 4,
        opacity: 0.9,
        interactive: false
      }).addTo(STATE.layers.trackLayer);

      map.setView([APP.defaultCenter.lat, APP.defaultCenter.lon], APP.defaultZoom);

      map.on("dragstart", () => {
        STATE.ui.mapUserInteracting = true;
        STATE.ui.followGps = false;
        updateFollowToggleUi();
        cancelLongPress();
      });
      map.on("dragend", () => setTimeout(()=>STATE.ui.mapUserInteracting = false, 120));
      map.on("zoomstart", cancelLongPress);

      map.on("click", (e) => {
        if (!STATE.ui.mapPickMode) return;
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        const which = STATE.ui.mapPickWhich || "A";

        setPointFromMap(which, lat, lon);

        const next = pickNextPoint(which);
        if (next) {
          STATE.ui.mapPickWhich = next;
          setMapPickHint(next, true);
          showSnackbar(`Punkt ${which} gesetzt. Jetzt Punkt ${next}.`, 1800);
        } else {
          stopMapPick();
          showSnackbar(`Punkt ${which} gesetzt.`, 1600);
        }
      });

      installLongPress(map);
      ensureBalloonMarker();
    }

    function setBaseLayer(which) {
      if (!STATE.map) return;
      STATE.ui.base = which === "sat" ? "sat" : "osm";
      try {
        if (STATE.ui.base === "sat") {
          STATE.map.removeLayer(STATE.layers.baseOSM);
          STATE.layers.baseSAT.addTo(STATE.map);
        } else {
          STATE.map.removeLayer(STATE.layers.baseSAT);
          STATE.layers.baseOSM.addTo(STATE.map);
        }
      } catch {}
    }

    function ensureBalloonMarker() {
      if (!STATE.map) return;

      if (STATE.balloon.marker) {
        if (!STATE.balloon.el) {
          const el = STATE.balloon.marker.getElement?.();
          STATE.balloon.el = el ? el.querySelector(".balloon-rot") : null;
        }
        return;
      }

      const icon = L.divIcon({
        className: "",
        iconSize: [34, 34],
        iconAnchor: [17, 17],
        html: `
          <div class="balloon-rot" style="width:34px;height:34px;display:grid;place-items:center;transform:rotate(0deg);">
            <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 2l7 19-7-4-7 4 7-19z" fill="#38bdf8" stroke="#0b1220" stroke-width="1.5" />
            </svg>
          </div>
        `
      });

      const p = getCurrentPos() || APP.defaultCenter;
      STATE.balloon.marker = L.marker([p.lat, p.lon], {
        icon,
        interactive: false,
        zIndexOffset: 1000
      }).addTo(STATE.map);

      setTimeout(() => {
        try {
          const el = STATE.balloon.marker.getElement?.();
          STATE.balloon.el = el ? el.querySelector(".balloon-rot") : null;
        } catch {}
      }, 0);
    }

    function setBalloonPose(lat, lon, headingDegVal) {
      if (!STATE.map) return;
      if (!STATE.balloon.marker) ensureBalloonMarker();

      try { STATE.balloon.marker.setLatLng([lat, lon]); } catch {}

      if (!STATE.balloon.el) {
        try {
          const el = STATE.balloon.marker.getElement?.();
          STATE.balloon.el = el ? el.querySelector(".balloon-rot") : null;
        } catch {}
      }
      if (STATE.balloon.el) {
        STATE.balloon.el.style.transform = `rotate(${headingDegVal || 0}deg)`;
      }
    }

    function installLongPress(map) {
      const container = map.getContainer();
      if (!container) return;

      container.addEventListener("pointerdown", (ev) => {
        try {
          if (ev.button != null && ev.button !== 0) return;
          if (STATE.ui.mapPickMode) return;
          if (STATE.ui.longPress.pointerId != null) return;

          const rect = container.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;

          STATE.ui.longPress.pointerId = ev.pointerId;
          STATE.ui.longPress.startX = x;
          STATE.ui.longPress.startY = y;
          STATE.ui.longPress.active = true;
          STATE.ui.longPress.startLatLng = map.containerPointToLatLng(L.point(x, y));

          STATE.ui.longPress.timer = setTimeout(() => {
            if (!STATE.ui.longPress.active) return;
            if (STATE.ui.mapUserInteracting) return;
            const ll = STATE.ui.longPress.startLatLng;
            if (!ll) return;

            // free waypoint
            setWaypoint(ll.lat, ll.lng);
            cancelLongPress(true);
          }, APP.longPressMs);

          try { container.setPointerCapture(ev.pointerId); } catch {}
        } catch {}
      }, { passive: true });

      container.addEventListener("pointermove", (ev) => {
        if (!STATE.ui.longPress.active) return;
        if (STATE.ui.longPress.pointerId !== ev.pointerId) return;

        const rect = container.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;

        const dx = x - STATE.ui.longPress.startX;
        const dy = y - STATE.ui.longPress.startY;
        if (Math.hypot(dx, dy) > APP.longPressMovePx) {
          cancelLongPress();
        }
      }, { passive: true });

      const end = (ev) => {
        if (!STATE.ui.longPress.active) return;
        if (STATE.ui.longPress.pointerId !== ev.pointerId) return;
        cancelLongPress();
      };

      container.addEventListener("pointerup", end, { passive: true });
      container.addEventListener("pointercancel", end, { passive: true });
      container.addEventListener("pointerleave", () => cancelLongPress(), { passive: true });
    }

    function cancelLongPress() {
      STATE.ui.longPress.active = false;
      try { clearTimeout(STATE.ui.longPress.timer); } catch {}
      STATE.ui.longPress.timer = null;
      STATE.ui.longPress.pointerId = null;
      STATE.ui.longPress.startLatLng = null;
    }

    function setWaypoint(lat, lon) {
      STATE.waypoint = { active: { lat, lon, ts: now() } };
      drawWaypoint();
      updateButtons();
      updateNavToast();
      persistAll();
      showSnackbar("Waypoint gesetzt (long press).", 1800);
    }

    function clearWaypoint() {
      STATE.waypoint = { active: null };
      try { STATE.layers.waypointLayer?.clearLayers(); } catch {}
      updateButtons();
      updateNavToast();
      persistAll();
      showSnackbar("Waypoint entfernt.", 1600);
    }

    function drawWaypoint() {
      if (!STATE.map || !STATE.layers.waypointLayer) return;
      try { STATE.layers.waypointLayer.clearLayers(); } catch {}
      if (!STATE.waypoint?.active) return;

      const wp = STATE.waypoint.active;
      const latlng = [wp.lat, wp.lon];

      const mk = L.circleMarker(latlng, {
        radius: 10,
        color: "#fbbf24",
        weight: 3,
        fillColor: "#fbbf24",
        fillOpacity: 0.20,
        interactive: true
      }).addTo(STATE.layers.waypointLayer);
      mk.on("click", () => clearWaypoint());

      L.marker(latlng, {
        icon: L.divIcon({ className:"", iconSize:[1,1], html:`<div class="mono text-xs font-extrabold" style="color:#fbbf24;text-shadow:0 6px 16px rgba(0,0,0,.45)">WP</div>` }),
        interactive:false
      }).addTo(STATE.layers.waypointLayer);
    }

    function renderTaskTypeOptions() {
      const sel = document.getElementById("taskType");
      if (!sel) return;
      sel.innerHTML = CIA_TASKS.map(t => `<option value="${t.code}">${t.num} ${t.code} — ${escapeXml(t.title)}</option>`).join("");
    }

    function renderTaskFieldsForCode(code) {
      const wrap = document.getElementById("taskFields");
      if (!wrap) return;

      const is3DT = code === "3DT";
      const isANG = code === "ANG";
      const isLRN = code === "LRN";

      const pointCard = (label, which) => `
        <div class="rounded-2xl bg-slate-950/40 border border-slate-800 p-3">
          <div class="flex items-center justify-between mb-2">
            <div class="font-extrabold">${escapeXml(label)}</div>
            <button type="button" data-pick="${which}" class="btn-touch h-9 px-3 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">
              <i class="fa-solid fa-crosshairs mr-2"></i>auf Karte
            </button>
          </div>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <div class="text-xs text-slate-400 mb-1">Lat</div>
              <input id="task${which}Lat" type="number" step="0.000001" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="49.123456" />
            </div>
            <div>
              <div class="text-xs text-slate-400 mb-1">Lon</div>
              <input id="task${which}Lon" type="number" step="0.000001" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="8.123456" />
            </div>
          </div>
        </div>
      `;

      const radiusFields = `
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-400 mb-1">${is3DT ? "Innenradius (m)" : "Radius 1 (m)"}</div>
            <input id="taskR1" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 50" />
          </div>
          <div>
            <div class="text-xs text-slate-400 mb-1">${is3DT ? "Außenradius (m)" : "Radius 2 (m)"}</div>
            <input id="taskR2" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 200" />
          </div>
        </div>
      `;

      const altFields = `
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-400 mb-1">Min Höhe (m)</div>
            <input id="taskMinAlt" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="optional" />
          </div>
          <div>
            <div class="text-xs text-slate-400 mb-1">Max Höhe (m)</div>
            <input id="taskMaxAlt" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="optional" />
          </div>
        </div>
      `;

      const angFields = isANG ? `
        <div>
          <div class="text-xs text-slate-400 mb-1">Vorgegebene Richtung (°)</div>
          <input id="taskSetDir" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="0..359" />
        </div>
      ` : "";

      let coordsHtml = "";
      if (isANG || isLRN) {
        coordsHtml = `
          ${pointCard("Punkt A", "A")}
          ${pointCard("Punkt B", "B")}
          ${isLRN ? pointCard("Punkt C", "C") : ""}
        `;
      } else {
        coordsHtml = `${pointCard("Ziel", "A")}`;
      }

      wrap.innerHTML = `
        <div class="text-xs text-slate-400 mb-1">Koordinaten</div>
        <div class="space-y-3">${coordsHtml}</div>
        <div class="mt-3">${radiusFields}</div>
        <div class="mt-3">${angFields}</div>
        <div class="mt-3">${altFields}</div>
      `;

      wrap.querySelectorAll("[data-pick]").forEach(btn => {
        btn.addEventListener("click", () => startMapPick(btn.getAttribute("data-pick")));
      });
    }

    function startMapPick(which) {
      STATE.ui.mapPickMode = true;
      STATE.ui.mapPickWhich = which || "A";
      openDrawer(false);
      setMapPickHint(STATE.ui.mapPickWhich, true);
      showSnackbar(`Karte tippen: Punkt ${STATE.ui.mapPickWhich} setzen.`, 1800);
    }
    function stopMapPick() {
      STATE.ui.mapPickMode = false;
      setMapPickHint("A", false);
    }

    function updatePickMarker(which, lat, lon) {
      if (!STATE.layers.pickLayer || !STATE.map) return;
      const prev = STATE.ui.pickMarkers[which];
      if (prev) {
        try { STATE.layers.pickLayer.removeLayer(prev); } catch {}
        STATE.ui.pickMarkers[which] = null;
      }
      const color = which === "A" ? "#60a5fa" : (which === "B" ? "#22d3ee" : "#a78bfa");
      const g = L.layerGroup();
      L.circleMarker([lat, lon], { radius: 10, color, weight: 3, fillColor: color, fillOpacity: 0.25, interactive: false }).addTo(g);
      L.marker([lat, lon], {
        icon: L.divIcon({ className:"", iconSize:[1,1], html:`<div class="mono text-xs font-extrabold" style="color:${color};text-shadow:0 6px 16px rgba(0,0,0,.45)">${which}</div>` }),
        interactive:false
      }).addTo(g);
      STATE.layers.pickLayer.addLayer(g);
      STATE.ui.pickMarkers[which] = g;
    }

    function setPointFromMap(which, lat, lon) {
      const latEl = document.getElementById(`task${which}Lat`);
      const lonEl = document.getElementById(`task${which}Lon`);
      if (latEl) latEl.value = lat.toFixed(6);
      if (lonEl) lonEl.value = lon.toFixed(6);
      updatePickMarker(which, lat, lon);
    }

    function pickNextPoint(which) {
      const order = ["A", "B", "C"];
      const idx = order.indexOf(which);
      for (let i = idx + 1; i < order.length; i++) {
        const w = order[i];
        const latEl = document.getElementById(`task${w}Lat`);
        const lonEl = document.getElementById(`task${w}Lon`);
        if (!latEl || !lonEl) continue;
        const latVal = safeFloat(latEl.value, null);
        const lonVal = safeFloat(lonEl.value, null);
        if (latVal == null || lonVal == null) return w;
      }
      return null;
    }

    function initGPS() {
      if (!("geolocation" in navigator)) {
        showSnackbar("Geolocation nicht verfügbar.");
        return;
      }
      stopGPS();
      const opts = { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 };
      STATE.gps.watchId = navigator.geolocation.watchPosition(
        (pos) => { try { onGpsPosition(pos); } catch (e) { console.error(e); } },
        (err) => {
          console.warn(err);
          STATE.gps.hasFix = false;
          updateGpsBadge();
        },
        opts
      );
    }

    function stopGPS() {
      try {
        if (STATE.gps.watchId != null) navigator.geolocation.clearWatch(STATE.gps.watchId);
      } catch {}
      STATE.gps.watchId = null;
    }

    function onGpsPosition(pos) {
      if (STATE.sim.enabled) return;

      const c = pos.coords;
      const lat = c.latitude;
      const lon = c.longitude;
      const alt = Number.isFinite(c.altitude) ? c.altitude : null;
      const spdKmh = Number.isFinite(c.speed) ? (c.speed * 3.6) : 0;
      const head = Number.isFinite(c.heading) ? c.heading : null;
      const acc = Number.isFinite(c.accuracy) ? c.accuracy : null;

      if (STATE.gps.smoothLat != null && STATE.gps.smoothLon != null) {
        const d = haversineM({ lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon }, { lat, lon });
        const dyn = clamp((spdKmh/3.6) * 3 + 60, 80, 220);
        if (d > Math.max(APP.maxGpsJumpM, dyn)) return;
      }

      STATE.gps.smoothLat = smooth(STATE.gps.smoothLat, lat, APP.gpsSmoothingAlpha);
      STATE.gps.smoothLon = smooth(STATE.gps.smoothLon, lon, APP.gpsSmoothingAlpha);

      let course = head;
      if (course == null) {
        if (STATE.gps.lat != null && STATE.gps.lon != null) {
          const d = haversineM({ lat: STATE.gps.lat, lon: STATE.gps.lon }, { lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon });
          if (d > 4) course = bearingDeg({ lat: STATE.gps.lat, lon: STATE.gps.lon }, { lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon });
        }
      }
      if (course != null && isFinite(course)) STATE.gps.lastCourseDeg = ((course%360)+360)%360;

      STATE.gps.lat = STATE.gps.smoothLat;
      STATE.gps.lon = STATE.gps.smoothLon;
      STATE.gps.altM = alt;
      STATE.gps.speedKmh = spdKmh;
      STATE.gps.headingDeg = head;
      STATE.gps.accuracyM = acc;
      STATE.gps.hasFix = true;
      STATE.gps.fixTs = now();

      ensureBalloonMarker();
      setBalloonPose(STATE.gps.lat, STATE.gps.lon, getCourseDeg());

      if (STATE.ui.followGps && !STATE.ui.mapUserInteracting) {
        const ts = now();
        if (ts - STATE.gps.lastPanTs > APP.followPanMinMs) {
          STATE.gps.lastPanTs = ts;
          STATE.map?.panTo([STATE.gps.lat, STATE.gps.lon], { animate: true, duration: 0.35 });
        }
      }

      if (STATE.flight.active) {
        maybeAddTrackPoint({ lat: STATE.gps.lat, lon: STATE.gps.lon, altM: alt, ts: now() });
        maybeAutoRecordWind({ altM: alt, courseDeg: getCourseDeg(), speedKmh: spdKmh, ts: now() });
      }

      updateGpsBadge();
      updateInstruments();
      updateButtons();
      updateNavToast();
      updateWindHud();
      rebuildTrajectory();
      persistAllThrottled();
    }

    function maybeAddTrackPoint(p) {
      if (!STATE.flight.active) return;
      if (!p || p.lat == null || p.lon == null) return;

      const track = STATE.flight.track;
      if (track.length) {
        const last = track[track.length-1];
        const d = haversineM({ lat:last.lat, lon:last.lon }, { lat:p.lat, lon:p.lon });
        if (d < APP.trackMinDistM) return;
      }

      track.push({ lat:p.lat, lon:p.lon, altM:p.altM, ts:p.ts });
      if (track.length > APP.maxTrackPoints) track.shift();
      try { STATE.layers.trackLine?.setLatLngs(track.map(x => [x.lat, x.lon])); } catch {}
    }

    function maybeAutoRecordWind({ altM, courseDeg, speedKmh }) {
      if (!STATE.flight.active) return;
      if (speedKmh == null || speedKmh < 10) return;
      if (altM == null || !isFinite(altM)) return;

      const last = STATE.wind.lastAuto;
      const dAlt = last.altM == null ? 9999 : Math.abs(altM - last.altM);
      const dCrs = last.courseDeg == null ? 9999 : angDiffDeg(courseDeg, last.courseDeg);

      if (dAlt > 50 || dCrs > 5) {
        const fromDeg = (courseDeg + 180) % 360;
        addWindLayer({ altM, fromDeg, speedKmh, ts: now(), source: "auto" });
        STATE.wind.lastAuto = { altM, courseDeg, ts: now() };
      }
    }

    function addWindLayer(w) {
      const alt = Math.round(w.altM);
      const from = ((Math.round(w.fromDeg)%360)+360)%360;
      const spd = Math.max(0, safeFloat(w.speedKmh, 0));
      const ts = w.ts || now();

      const idx = STATE.wind.layers.findIndex(x => Math.abs(x.altM - alt) <= 15);
      const item = { altM: alt, fromDeg: from, speedKmh: spd, ts, source: w.source || "manual" };
      if (idx >= 0) STATE.wind.layers[idx] = item;
      else STATE.wind.layers.push(item);
      STATE.wind.layers.sort((a,b)=>a.altM-b.altM);

      persistAll();
      updateWindPanel();
      updateWindHud();
      updateNavToast();
      rebuildTrajectory();
    }

    function updateWindPanel() {
      const list = document.getElementById("windList");
      if (!list) return;
      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Keine Schichten vorhanden.</div>`;
        return;
      }
      list.innerHTML = items.map((w, idx) => `
        <div class="flex items-center gap-2 rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
          <div class="flex-1">
            <div class="font-extrabold mono">${Math.round(w.altM)} m</div>
            <div class="text-xs text-slate-400 mono">${Math.round(w.fromDeg)}° FROM • ${fmtNum(w.speedKmh,1)} km/h</div>
          </div>
          <button data-widx="${idx}" class="btn-touch btnDelWind h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-trash"></i>
          </button>
        </div>
      `).join("");

      list.querySelectorAll(".btnDelWind").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const idx = parseInt(e.currentTarget.getAttribute("data-widx"), 10);
          if (!Number.isFinite(idx)) return;
          STATE.wind.layers.splice(idx, 1);
          persistAll();
          updateWindPanel();
          updateWindHud();
          updateNavToast();
          rebuildTrajectory();
        });
      });
    }

    function windAtAltitude(altM) {
      if (!STATE.wind.layers.length || altM == null) return null;
      let best = null, bestD = Infinity;
      for (const w of STATE.wind.layers) {
        const d = Math.abs(w.altM - altM);
        if (d < bestD) { bestD = d; best = w; }
      }
      return best;
    }

    function rebuildTrajectory() {
      if (!STATE.map || !STATE.layers.trajectoryLayer) return;
      try { STATE.layers.trajectoryLayer.clearLayers(); } catch {}
      const pos = getCurrentPos();
      const alt = getCurrentAltM();
      if (!pos || alt == null) return;

      const w = windAtAltitude(alt);
      if (!w) return;

      const driftTo = windToDegFrom(w.fromDeg);
      const spdMps = Math.max(0, (w.speedKmh||0) / 3.6);
      if (spdMps < 0.1) return;

      const mins = [5,10,15];
      mins.forEach((m, idx) => {
        const dist = spdMps * (m*60);
        const q = destPoint(pos, driftTo, dist);
        L.polyline([[pos.lat,pos.lon],[q.lat,q.lon]], {
          color: "#22c55e",
          weight: 4,
          opacity: 0.75,
          dashArray: idx === 0 ? null : (idx === 1 ? "8 8" : "3 10"),
          interactive:false
        }).addTo(STATE.layers.trajectoryLayer);
      });
    }

    function getPrimaryTarget(task) {
      if (!task) return null;
      if (task.code === "3DT" && task.center) return task.center;
      if (task.points && task.points.length) return { lat: task.points[0].lat, lon: task.points[0].lon };
      return null;
    }

    function recommendLayerText(task, pos, target) {
      if (task && task.code === "3DT" && task.center && task.r1M && task.r2M) {
        const dC = haversineM(pos, task.center);
        if (dC < task.r1M) return "Ungültig (im inneren Kreis)";
        if (dC <= task.r2M) return "Im Ring: Distanz maximieren";
        return "Außerhalb: Ziel = Zentrum";
      }

      if (!STATE.wind.layers.length) return "Kein Windprofil";
      const brg = bearingDeg(pos, target);

      let best = null, bestScore = Infinity;
      for (const w of STATE.wind.layers) {
        const driftTo = windToDegFrom(w.fromDeg);
        const score = angDiffDeg(driftTo, brg);
        if (score < bestScore) { bestScore = score; best = w; }
      }
      if (!best) return "Kein Layer";

      const curAlt = getCurrentAltM();
      const need = Math.round(best.altM);
      if (curAlt == null) return `Layer: ${need}m`;
      const dAlt = need - curAlt;
      if (Math.abs(dAlt) < 25) return `Halten ~${need}m`;
      return dAlt > 0 ? `Steigen auf ${need}m` : `Sinken auf ${need}m`;
    }

    function clearTaskOverlays() { try { STATE.layers.tasksLayer?.clearLayers(); } catch {} }

    function drawTaskOnMap(task) {
      clearTaskOverlays();
      if (!task || !STATE.map) return;

      const NI = { interactive:false };

      if (task.points && task.points.length) {
        task.points.forEach((p, idx) => {
          const color = idx === 0 ? "#60a5fa" : "#93c5fd";
          L.circleMarker([p.lat, p.lon], { radius: 9, color, weight: 3, fillColor: color, fillOpacity: 0.25, ...NI })
            .addTo(STATE.layers.tasksLayer);
          L.marker([p.lat, p.lon], {
            icon: L.divIcon({ className:"", iconSize:[1,1], html:`<div class="mono text-xs font-extrabold" style="color:${color};text-shadow:0 6px 16px rgba(0,0,0,.45)">${escapeXml(p.name||String.fromCharCode(65+idx))}</div>` }),
            interactive:false
          }).addTo(STATE.layers.tasksLayer);
        });
      }

      const center = task.center || (task.points && task.points[0] ? { lat: task.points[0].lat, lon: task.points[0].lon } : null);
      if (center && (task.r2M || task.r1M)) {
        if (task.r2M) L.circle([center.lat, center.lon], { radius: task.r2M, color: "#60a5fa", weight: 3, opacity: 0.9, fillOpacity: 0.05, ...NI }).addTo(STATE.layers.tasksLayer);
        if (task.r1M) L.circle([center.lat, center.lon], { radius: task.r1M, color: "#93c5fd", weight: 2, opacity: 0.8, dashArray: "6 8", fillOpacity: 0.01, ...NI }).addTo(STATE.layers.tasksLayer);
      }

      if (task.code === "ANG" && task.points && task.points.length >= 2) {
        L.polyline(task.points.slice(0,2).map(p => [p.lat,p.lon]), { color:"#38bdf8", weight:3, opacity:0.9, dashArray:"8 8", ...NI }).addTo(STATE.layers.tasksLayer);
      }
      if (task.code === "LRN" && task.points && task.points.length >= 3) {
        const pts = task.points.slice(0,3).map(p => [p.lat,p.lon]);
        pts.push([task.points[0].lat, task.points[0].lon]);
        L.polyline(pts, { color:"#38bdf8", weight:3, opacity:0.9, ...NI }).addTo(STATE.layers.tasksLayer);
      }
    }

    function buildTaskFromForm() {
      const code = document.getElementById("taskType")?.value;
      const meta = CIA_TASKS.find(x => x.code === code);
      if (!code || !meta) return null;

      const title = document.getElementById("taskTitle")?.value?.trim() || "";
      const r1 = safeFloat(document.getElementById("taskR1")?.value, null);
      const r2 = safeFloat(document.getElementById("taskR2")?.value, null);
      const minAlt = safeFloat(document.getElementById("taskMinAlt")?.value, null);
      const maxAlt = safeFloat(document.getElementById("taskMaxAlt")?.value, null);
      const setDir = safeFloat(document.getElementById("taskSetDir")?.value, null);

      const markerCount = clamp(parseInt(document.getElementById("taskMarkerCount")?.value || "0", 10) || 0, 0, APP.maxMarkerButtons);

      const markerColors = [];
      document.querySelectorAll("#taskMarkerColors input[type='color']").forEach(inp => markerColors.push(inp.value || "#fb7185"));

      const points = [];
      const aLat = safeFloat(document.getElementById("taskALat")?.value, null);
      const aLon = safeFloat(document.getElementById("taskALon")?.value, null);
      if (aLat != null && aLon != null) points.push({ name:"A", lat:aLat, lon:aLon });

      const bLat = safeFloat(document.getElementById("taskBLat")?.value, null);
      const bLon = safeFloat(document.getElementById("taskBLon")?.value, null);
      if (bLat != null && bLon != null) points.push({ name:"B", lat:bLat, lon:bLon });

      const cLat = safeFloat(document.getElementById("taskCLat")?.value, null);
      const cLon = safeFloat(document.getElementById("taskCLon")?.value, null);
      if (cLat != null && cLon != null) points.push({ name:"C", lat:cLat, lon:cLon });

      const task = {
        id: uid(),
        code,
        typeTitle: meta.title,
        title,
        points,
        r1M: r1 != null ? Math.max(0, r1) : null,
        r2M: r2 != null ? Math.max(0, r2) : null,
        minAltM: minAlt,
        maxAltM: maxAlt,
        setDirDeg: setDir != null ? ((setDir%360)+360)%360 : null,
        center: null,

        markerCount,
        markerColors: ensureMarkerColorsArray({ markerColors }, markerCount),
      };

      if (task.code === "3DT") {
        if (points[0]) task.center = { lat: points[0].lat, lon: points[0].lon };
      }
      return task;
    }

    /***********************
     * Briefing CRUD
     ***********************/
    function createBriefing() {
      const b = {
        id: uid(),
        title: "Neues Briefing",
        startFrom: "",
        startTo: "",
        scoringEnd: "",
        orderMode: "fixed", // fixed | free
        tasks: [],
        createdTs: now(),
        updatedTs: now(),
      };
      STATE.briefings.list.push(b);
      STATE.ui.selectedBriefingId = b.id;
      STATE.ui.selectedBriefTaskId = null;
      persistAll();
      renderBriefingSelect();
      showSnackbar("Briefing erstellt.");
    }

    function duplicateBriefing() {
      const b = getSelectedBriefing();
      if (!b) { showSnackbar("Kein Briefing."); return; }
      const copy = JSON.parse(JSON.stringify(b));
      copy.id = uid();
      copy.title = (b.title || "Briefing") + " (Kopie)";
      copy.createdTs = now();
      copy.updatedTs = now();
      // new ids for tasks
      copy.tasks = (copy.tasks || []).map(t => ({ ...t, id: uid() }));
      STATE.briefings.list.push(copy);
      STATE.ui.selectedBriefingId = copy.id;
      STATE.ui.selectedBriefTaskId = null;
      persistAll();
      renderBriefingSelect();
      showSnackbar("Briefing dupliziert.");
    }

    function deleteBriefing() {
      const b = getSelectedBriefing();
      if (!b) { showSnackbar("Kein Briefing."); return; }
      STATE.briefings.list = STATE.briefings.list.filter(x => x.id !== b.id);
      if (STATE.briefings.activeId === b.id) STATE.briefings.activeId = null;
      if (STATE.ui.selectedBriefingId === b.id) STATE.ui.selectedBriefingId = STATE.briefings.list[0]?.id || null;
      STATE.ui.selectedBriefTaskId = null;
      persistAll();
      renderBriefingSelect();
      updateButtons();
      showSnackbar("Briefing gelöscht.");
    }

    function saveBriefingFromForm() {
      const b = getSelectedBriefing();
      if (!b) { showSnackbar("Kein Briefing."); return; }

      b.title = (document.getElementById("briefTitle")?.value || "").trim();
      b.startFrom = document.getElementById("briefStartFrom")?.value || "";
      b.startTo = document.getElementById("briefStartTo")?.value || "";
      b.scoringEnd = document.getElementById("briefScoringEnd")?.value || "";
      b.orderMode = document.getElementById("briefOrderMode")?.value === "free" ? "free" : "fixed";
      b.updatedTs = now();

      persistAll();
      renderBriefingSelect();
      showSnackbar("Briefing gespeichert.");
    }

    function activateBriefing() {
      const b = getSelectedBriefing();
      if (!b) { showSnackbar("Kein Briefing."); return; }
      STATE.briefings.activeId = b.id;
      // when switching active briefing, reset run state if flight active (keep flight track)
      if (STATE.flight.active) {
        STATE.flight.briefingRun = buildRunStateFromBriefing(b);
      }
      persistAll();
      updateButtons();
      renderBriefTasksList();
      showSnackbar("Briefing aktiviert.");
    }

    function deactivateBriefing() {
      STATE.briefings.activeId = null;
      STATE.flight.briefingRun = null;
      // also clear active task overlay if it came from briefing
      STATE.task.active = null;
      clearTaskOverlays();
      persistAll();
      updateButtons();
      updateNavToast();
      renderBriefTasksList();
      showSnackbar("Briefing deaktiviert.");
    }

    function addTaskToSelectedBriefing() {
      const b = getSelectedBriefing();
      if (!b) { showSnackbar("Bitte erst Briefing anlegen."); return; }

      const t = buildTaskFromForm();
      if (!t) { showSnackbar("Task unvollständig."); return; }
      // require at least A for those with target-based navigation (except pure track tasks)
      const needPoint = !(t.code === "ELB" || t.code === "LRN" || t.code === "RTA" || t.code === "3DT" || t.code === "APT" || t.code === "ANG");
      if (needPoint && (!t.points || !t.points.length)) {
        showSnackbar("Bitte Koordinaten setzen (mind. A).");
        return;
      }

      // If markerCount was left 0 but default suggests something, keep user choice (free) — but you said derived:
      // We'll auto-fill if empty AND default>0.
      if ((t.markerCount ?? 0) === 0) {
        const def = defaultMarkerCountForTask(t.code);
        if (def > 0) {
          t.markerCount = def;
          t.markerColors = ensureMarkerColorsArray(t, def);
        }
      }

      b.tasks = b.tasks || [];
      b.tasks.push(t);
      b.updatedTs = now();

      STATE.ui.selectedBriefTaskId = t.id;

      persistAll();
      renderBriefingSelect();
      renderBriefTasksList();
      showSnackbar("Task zum Briefing hinzugefügt.");
    }

    function deleteTaskFromBriefing(taskId) {
      const b = getSelectedBriefing();
      if (!b) return;
      b.tasks = (b.tasks || []).filter(t => t.id !== taskId);
      b.updatedTs = now();

      if (STATE.ui.selectedBriefTaskId === taskId) STATE.ui.selectedBriefTaskId = b.tasks[0]?.id || null;

      // if active briefing + running state references this task, rebuild run state
      if (STATE.briefings.activeId === b.id && STATE.flight.briefingRun) {
        if (STATE.flight.briefingRun.activeTaskId === taskId) {
          STATE.flight.briefingRun.activeTaskId = null;
          STATE.task.active = null;
          clearTaskOverlays();
        }
        STATE.flight.briefingRun = buildRunStateFromBriefing(b, STATE.flight.briefingRun);
      }

      persistAll();
      renderBriefingSelect();
      renderBriefTasksList();
      updateButtons();
      showSnackbar("Task gelöscht.");
    }

    function moveTaskInBriefing(taskId, dir) {
      const b = getSelectedBriefing();
      if (!b || !b.tasks) return;
      const i = b.tasks.findIndex(t => t.id === taskId);
      if (i < 0) return;
      const j = i + dir;
      if (j < 0 || j >= b.tasks.length) return;
      const tmp = b.tasks[i]; b.tasks[i] = b.tasks[j]; b.tasks[j] = tmp;
      b.updatedTs = now();
      persistAll();
      renderBriefTasksList();
    }

    function activateBriefingTask(taskId, allowFree=true) {
      const b = getSelectedBriefing();
      if (!b) { showSnackbar("Kein Briefing ausgewählt."); return; }
      const task = getBriefTask(b, taskId);
      if (!task) return;

      // if briefing is active and flight active, enforce modes
      if (STATE.briefings.activeId === b.id && STATE.flight.active && STATE.flight.briefingRun) {
        const mode = b.orderMode || "fixed";
        if (mode === "fixed" && allowFree) {
          // fixed mode: only allow selecting current or next
          const nextId = getNextTaskIdInRun(b, STATE.flight.briefingRun);
          const curId = STATE.flight.briefingRun.activeTaskId;
          if (taskId !== curId && taskId !== nextId) {
            showSnackbar("Fix-Modus: nur aktueller oder nächster Task.");
            return;
          }
        }
        ensureRunStateHasTask(STATE.flight.briefingRun, task);
        STATE.flight.briefingRun.activeTaskId = taskId;
      }

      // also set navigation task overlay (even in briefing planning)
      STATE.task.active = { ...task };
      drawTaskOnMap(STATE.task.active);
      updateButtons();
      updateNavToast();
      persistAll();
      showSnackbar("Task aktiv auf Karte.");
    }

    function clearActiveTaskOverlay() {
      STATE.task.active = null;
      clearTaskOverlays();
      updateButtons();
      updateNavToast();
      persistAll();
      showSnackbar("Task Overlay entfernt.");
    }

    function markTaskDone(taskId) {
      const b = getActiveBriefing();
      const run = STATE.flight.briefingRun;
      if (!STATE.flight.active || !b || !run) { showSnackbar("Nur während aktiver Fahrt mit Briefing."); return; }

      const st = run.taskStates?.find(s => s.taskId === taskId);
      if (!st) { showSnackbar("Task-State fehlt."); return; }
      st.finishedTs = now();

      // auto advance in fixed mode
      if ((b.orderMode || "fixed") === "fixed") {
        const nextId = getNextTaskIdInRun(b, run);
        if (nextId) {
          run.activeTaskId = nextId;
          const nt = getBriefTask(b, nextId);
          if (nt) activateBriefingTask(nextId, false);
        } else {
          run.activeTaskId = null;
          clearActiveTaskOverlay();
        }
      }

      persistAll();
      renderBriefTasksList();
      updateButtons();
      updateNavToast();
      showSnackbar("Task als Done markiert.");
    }

    function nextTask() {
      const b = getActiveBriefing();
      const run = STATE.flight.briefingRun;
      if (!STATE.flight.active || !b || !run) { showSnackbar("Nur während aktiver Fahrt mit Briefing."); return; }
      if ((b.orderMode || "fixed") !== "fixed") { showSnackbar("Frei-Modus: wähle Task direkt."); return; }

      const nextId = getNextTaskIdInRun(b, run);
      if (!nextId) { showSnackbar("Kein weiterer Task."); return; }
      run.activeTaskId = nextId;
      activateBriefingTask(nextId, false);
      persistAll();
      renderBriefTasksList();
      updateButtons();
      updateNavToast();
    }

    function buildRunStateFromBriefing(briefing, prevRun=null) {
      const tasks = briefing.tasks || [];
      const run = {
        briefingId: briefing.id,
        activeTaskId: prevRun?.activeTaskId || null,
        taskStates: tasks.map(t => {
          const prev = prevRun?.taskStates?.find(s => s.taskId === t.id);
          const mc = Math.max(0, Math.min(APP.maxMarkerButtons, t.markerCount ?? 0));
          return {
            taskId: t.id,
            startedTs: prev?.startedTs || null,
            finishedTs: prev?.finishedTs || null,
            usedMarkers: Array.from({length:mc}).map((_,i)=> !!prev?.usedMarkers?.[i]),
          };
        })
      };

      // if activeTaskId no longer exists, clear
      if (run.activeTaskId && !tasks.some(t => t.id === run.activeTaskId)) run.activeTaskId = null;

      // if no activeTaskId, set first not-done in fixed mode
      if (!run.activeTaskId && (briefing.orderMode || "fixed") === "fixed") {
        const first = tasks.find(t => {
          const st = run.taskStates.find(s => s.taskId === t.id);
          return !st?.finishedTs;
        });
        if (first) run.activeTaskId = first.id;
      }
      return run;
    }

    function ensureRunStateHasTask(run, task) {
      if (!run.taskStates) run.taskStates = [];
      if (run.taskStates.some(s => s.taskId === task.id)) return;
      const mc = Math.max(0, Math.min(APP.maxMarkerButtons, task.markerCount ?? 0));
      run.taskStates.push({ taskId: task.id, startedTs:null, finishedTs:null, usedMarkers:Array.from({length:mc}).map(()=>false) });
    }

    function getNextTaskIdInRun(briefing, run) {
      const tasks = briefing.tasks || [];
      if (!tasks.length) return null;

      const cur = run.activeTaskId;
      if (!cur) {
        const first = tasks.find(t => {
          const st = run.taskStates?.find(s => s.taskId === t.id);
          return !st?.finishedTs;
        });
        return first?.id || null;
      }

      const idx = tasks.findIndex(t => t.id === cur);
      for (let i = idx + 1; i < tasks.length; i++) {
        const t = tasks[i];
        const st = run.taskStates?.find(s => s.taskId === t.id);
        if (!st?.finishedTs) return t.id;
      }
      return null;
    }

    function getTaskProgressLabel(briefing, run, taskId) {
      const st = run.taskStates?.find(s => s.taskId === taskId);
      if (!st) return "";
      if (st.finishedTs) return "DONE";
      const used = (st.usedMarkers||[]).filter(Boolean).length;
      const total = (st.usedMarkers||[]).length;
      if (total > 0) return `${used}/${total}`;
      return "";
    }

    function beginFlight(title) {
      if (STATE.flight.active) return;

      STATE.flight.active = true;
      STATE.flight.title = title || "Fahrt";
      STATE.flight.startedTs = now();
      STATE.flight.track = [];
      STATE.flight.markers = [];
      try { STATE.layers.trackLine?.setLatLngs([]); } catch {}
      try { STATE.layers.markersLayer?.clearLayers(); } catch {}

      STATE.gps.lastAltM = null;
      STATE.gps.lastAltTs = null;
      STATE.wind.lastAuto = { altM: null, courseDeg: null, ts: 0 };

      // if briefing active, create run state
      const b = getActiveBriefing();
      if (b) {
        STATE.flight.briefingRun = buildRunStateFromBriefing(b);
        // set active task (fixed mode => first), free mode => none until picked
        if (STATE.flight.briefingRun.activeTaskId) {
          const t = getBriefTask(b, STATE.flight.briefingRun.activeTaskId);
          if (t) {
            STATE.task.active = { ...t };
            drawTaskOnMap(STATE.task.active);
          }
        } else {
          STATE.task.active = null;
          clearTaskOverlays();
        }
      } else {
        STATE.flight.briefingRun = null;
      }

      updateButtons();
      updateNavToast();
      renderBriefTasksList();
      showSnackbar("Fahrt gestartet.");
      persistAll();
    }

    function finishFlight() {
      if (!STATE.flight.active) return;

      const endedTs = now();
      const flight = {
        id: uid(),
        title: STATE.flight.title || "Fahrt",
        startedTs: STATE.flight.startedTs,
        endedTs,
        track: STATE.flight.track.slice(0),
        markers: STATE.flight.markers.slice(0),
        briefingRun: STATE.flight.briefingRun ? JSON.parse(JSON.stringify(STATE.flight.briefingRun)) : null
      };

      STATE.flight.archive.push(flight);
      STATE.flight.active = false;
      STATE.flight.title = "";
      STATE.flight.startedTs = 0;
      STATE.flight.briefingRun = null;

      updateButtons();
      updateArchivePanel();
      renderBriefTasksList();
      showSnackbar("Fahrt beendet & archiviert.");
      persistAll();
    }

    function dropMarkerFromBriefingTask(markerIndex) {
      if (!STATE.flight.active) { showSnackbar("Bitte zuerst die Fahrt starten."); return; }

      const run = STATE.flight.briefingRun;
      const b = getActiveBriefing();
      if (!run || !b) { showSnackbar("Kein aktives Briefing für Marker."); return; }

      const taskId = run.activeTaskId;
      if (!taskId) { showSnackbar("Kein aktiver Task. Wähle Task im Briefing."); return; }

      const task = getBriefTask(b, taskId);
      if (!task) { showSnackbar("Task fehlt."); return; }

      const st = run.taskStates?.find(s => s.taskId === taskId);
      if (!st) { showSnackbar("Task-State fehlt."); return; }

      const mc = Math.max(0, Math.min(APP.maxMarkerButtons, task.markerCount ?? 0));
      if (markerIndex < 0 || markerIndex >= mc) return;
      if (st.usedMarkers?.[markerIndex]) { showSnackbar("Marker bereits verwendet."); return; }

      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position."); return; }

      const color = ensureMarkerColorsArray(task, mc)[markerIndex] || "#fb7185";
      const alt = getCurrentAltM();

      const m = {
        lat: pos.lat, lon: pos.lon, altM: alt, ts: now(),
        color,
        label: `${task.code}-M${markerIndex+1}`,
        taskId: task.id,
        taskCode: task.code
      };
      STATE.flight.markers.push(m);

      L.circleMarker([m.lat, m.lon], {
        radius: 8, color, weight: 3, fillColor: color, fillOpacity: 0.25, interactive: false
      }).addTo(STATE.layers.markersLayer);

      st.usedMarkers[markerIndex] = true;
      if (!st.startedTs) st.startedTs = now();

      persistAll();
      updateButtons();
      updateNavToast();
      renderBriefTasksList();
      showSnackbar(`Marker ${markerIndex+1} gesetzt.`);
    }

    function updateArchivePanel() {
      const list = document.getElementById("archiveList");
      if (!list) return;

      const items = [...STATE.flight.archive].sort((a,b)=>b.startedTs-a.startedTs);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Noch keine Fahrten im Archiv.</div>`;
        return;
      }

      list.innerHTML = items.map((f) => {
        const dt = new Date(f.startedTs);
        const durMin = f.endedTs ? Math.round((f.endedTs - f.startedTs)/60000) : 0;
        const mCount = (f.markers||[]).length;
        const tCount = (f.track||[]).length;
        const hasBrief = !!f.briefingRun?.briefingId;
        return `
          <div class="rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
            <div class="flex items-center gap-2">
              <div class="flex-1 min-w-0">
                <div class="font-extrabold truncate">${escapeXml(f.title || "Fahrt")}</div>
                <div class="text-xs text-slate-400">${dt.toLocaleString()} • ${durMin} min • ${tCount} pts • ${mCount} marks ${hasBrief ? "• Briefing" : ""}</div>
              </div>
              <button data-fid="${f.id}" class="btn-touch btnExport h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
                <i class="fa-solid fa-file-arrow-down mr-2"></i>KML
              </button>
            </div>
          </div>
        `;
      }).join("");

      list.querySelectorAll(".btnExport").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const fid = e.currentTarget.getAttribute("data-fid");
          const f = STATE.flight.archive.find(x => x.id === fid);
          if (!f) return;
          exportFlightToKml(f);
        });
      });
    }

    function exportFlightToKml(f) {
      try {
        const name = escapeXml(f.title || "CompNavAir");
        const trackCoords = (f.track || []).map(p => `${p.lon},${p.lat},${p.altM||0}`).join(" ");

        const markerPlacemarks = (f.markers || []).map(m => {
          const when = new Date(m.ts).toISOString();
          const desc = escapeXml(`${m.label || "MARK"}${m.taskCode ? ` (${m.taskCode})` : ""}`);
          return `
            <Placemark>
              <name>${escapeXml(m.label || "MARK")}</name>
              <description>${desc}</description>
              <TimeStamp><when>${when}</when></TimeStamp>
              <Point><coordinates>${m.lon},${m.lat},${m.altM||0}</coordinates></Point>
            </Placemark>
          `;
        }).join("\n");

        const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Style id="trackStyle"><LineStyle><color>ff4f46e5</color><width>4</width></LineStyle></Style>
    <Placemark>
      <name>Track</name>
      <styleUrl>#trackStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <altitudeMode>absolute</altitudeMode>
        <coordinates>${trackCoords}</coordinates>
      </LineString>
    </Placemark>
    ${markerPlacemarks}
  </Document>
</kml>`;

        const blob = new Blob([kml], { type: "application/vnd.google-earth.kml+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        const ts = new Date(f.startedTs).toISOString().slice(0,19).replaceAll(":","-");
        a.download = `CompNavAir_${ts}.kml`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
      } catch (e) {
        console.error(e);
        showSnackbar("KML Export fehlgeschlagen.");
      }
    }

    function importKmlFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const txt = String(reader.result || "");
          if (STATE.layers.kmlLayer) {
            try { STATE.map.removeLayer(STATE.layers.kmlLayer); } catch {}
            STATE.layers.kmlLayer = null;
          }
          const layer = omnivore.kml.parse(txt);
          layer.eachLayer(l => { if (l?.options) l.options.interactive = false; });
          layer.addTo(STATE.map);
          STATE.layers.kmlLayer = layer;
          showSnackbar("KML importiert.");
        } catch (e) {
          console.error(e);
          showSnackbar("KML Import fehlgeschlagen.");
        }
      };
      reader.readAsText(file);
    }

    async function requestWakeLock() {
      try {
        if (!("wakeLock" in navigator)) { showSnackbar("Wake Lock nicht unterstützt."); return; }
        STATE.ui.wakeLock = await navigator.wakeLock.request("screen");
        showSnackbar("Wake Lock aktiv.");
      } catch (e) {
        console.warn(e);
        showSnackbar("Wake Lock fehlgeschlagen.");
      }
    }

    /********************************************************************
     * Persistenz
     ********************************************************************/
    let _persistT = 0;
    function persistAllThrottled() {
      const t = now();
      if (t - _persistT < 1500) return;
      _persistT = t;
      persistAll();
    }

    function persistAll() {
      try {
        const payload = {
          version: APP.version,
          ui: { followGps: STATE.ui.followGps, base: STATE.ui.base, selectedBriefingId: STATE.ui.selectedBriefingId },
          wind: { layers: STATE.wind.layers },
          flight: {
            active: STATE.flight.active,
            title: STATE.flight.title,
            startedTs: STATE.flight.startedTs,
            track: STATE.flight.track,
            markers: STATE.flight.markers,
            archive: STATE.flight.archive,
            briefingRun: STATE.flight.briefingRun
          },
          sim: { enabled: STATE.sim.enabled },
          waypoint: { active: STATE.waypoint?.active || null },
          briefings: {
            activeId: STATE.briefings.activeId,
            list: STATE.briefings.list
          }
        };
        localStorage.setItem(APP.storageKey, JSON.stringify(payload));
      } catch {}
    }

    function restoreAll() {
      try {
        const raw = localStorage.getItem(APP.storageKey);
        if (!raw) return;
        const j = JSON.parse(raw);

        if (j.ui) {
          STATE.ui.followGps = !!j.ui.followGps;
          STATE.ui.base = j.ui.base === "sat" ? "sat" : "osm";
          STATE.ui.selectedBriefingId = j.ui.selectedBriefingId || null;
        }
        if (j.wind && Array.isArray(j.wind.layers)) {
          STATE.wind.layers = j.wind.layers.filter(x => x && isFinite(x.altM));
        }
        if (j.flight) {
          STATE.flight.active = !!j.flight.active;
          STATE.flight.title = j.flight.title || "";
          STATE.flight.startedTs = j.flight.startedTs || 0;
          STATE.flight.track = Array.isArray(j.flight.track) ? j.flight.track : [];
          STATE.flight.markers = Array.isArray(j.flight.markers) ? j.flight.markers : [];
          STATE.flight.archive = Array.isArray(j.flight.archive) ? j.flight.archive : [];
          STATE.flight.briefingRun = j.flight.briefingRun || null;
        }
        if (j.sim) STATE.sim.enabled = !!j.sim.enabled;
        if (j.waypoint) STATE.waypoint = { active: j.waypoint.active || null };
        if (j.briefings) {
          STATE.briefings.activeId = j.briefings.activeId || null;
          STATE.briefings.list = Array.isArray(j.briefings.list) ? j.briefings.list : [];
        }
      } catch {}
    }

    /********************************************************************
     * 6) EVENT-LISTENER & INITIALISIERUNG (window.onload am Ende)
     ********************************************************************/
    window.onload = () => {
      initManifestAndSW();
      restoreAll();

      initMap();
      setBaseLayer(STATE.ui.base);

      // Base UI
      updateGpsBadge();
      updateButtons();
      updateWindPanel();
      updateWindHud();
      updateArchivePanel();
      updateFollowToggleUi();
      rebuildTrajectory();

      // Tabs
      document.querySelectorAll(".tabBtn").forEach(b => {
        b.addEventListener("click", () => {
          STATE.ui.drawerTab = b.getAttribute("data-tab");
          updateDrawerTabUi();
        });
      });

      // Drawer open/close
      document.getElementById("btnMenu")?.addEventListener("click", () => openDrawer(true));
      document.getElementById("btnDrawerClose")?.addEventListener("click", () => openDrawer(false));
      document.getElementById("drawerBg")?.addEventListener("click", () => openDrawer(false));

      // Header buttons
      document.getElementById("btnWindHud")?.addEventListener("click", () => { STATE.ui.windHudOpen = !STATE.ui.windHudOpen; updateWindHud(); });
      document.getElementById("btnWindClose")?.addEventListener("click", () => { STATE.ui.windHudOpen = false; updateWindHud(); });
      document.getElementById("btnMapSettings")?.addEventListener("click", () => openMapModal(true));
      document.getElementById("btnMapModalClose")?.addEventListener("click", () => openMapModal(false));
      document.getElementById("mapModalBg")?.addEventListener("click", () => openMapModal(false));
      document.getElementById("btnBaseOSM")?.addEventListener("click", () => { setBaseLayer("osm"); persistAll(); });
      document.getElementById("btnBaseSAT")?.addEventListener("click", () => { setBaseLayer("sat"); persistAll(); });
      document.getElementById("btnCenter")?.addEventListener("click", () => {
        const p = getCurrentPos();
        if (!p || !STATE.map) return;
        STATE.ui.followGps = true;
        updateFollowToggleUi();
        STATE.map.panTo([p.lat, p.lon], { animate:true, duration:0.35 });
        showSnackbar("Zentriert.");
      });

      document.getElementById("tglFollow")?.addEventListener("change", (e) => {
        STATE.ui.followGps = !!e.target.checked;
        updateFollowToggleUi();
        persistAll();
      });

      // Flight controls
      document.getElementById("btnStartFlight")?.addEventListener("click", () => {
        const b = getActiveBriefing();
        const title = b ? `Briefing — ${b.title || "Fahrt"}` : "Fahrt";
        beginFlight(title);
      });
      document.getElementById("btnFinish")?.addEventListener("click", finishFlight);

      // Briefings UI init
      renderBriefingSelect();

      document.getElementById("briefingSelect")?.addEventListener("change", (e) => {
        STATE.ui.selectedBriefingId = e.target.value || null;
        STATE.ui.selectedBriefTaskId = null;
        renderBriefingForm();
        renderBriefTasksList();
        persistAll();
      });

      document.getElementById("btnBriefNew")?.addEventListener("click", createBriefing);
      document.getElementById("btnBriefDup")?.addEventListener("click", duplicateBriefing);
      document.getElementById("btnBriefSave")?.addEventListener("click", saveBriefingFromForm);
      document.getElementById("btnBriefDelete")?.addEventListener("click", deleteBriefing);
      document.getElementById("btnBriefActivate")?.addEventListener("click", activateBriefing);
      document.getElementById("btnBriefDeactivate")?.addEventListener("click", deactivateBriefing);

      // Task editor init
      renderTaskTypeOptions();
      const initialCode = document.getElementById("taskType")?.value || "JDG";
      renderTaskFieldsForCode(initialCode);

      // marker count defaults from task
      const mcEl = document.getElementById("taskMarkerCount");
      const applyDefaultMarkerForCode = (code) => {
        const def = defaultMarkerCountForTask(code);
        if (mcEl) mcEl.value = String(clamp(def, 0, APP.maxMarkerButtons));
        renderMarkerColorPickers(def, defaultMarkerColors(def));
      };
      applyDefaultMarkerForCode(initialCode);

      document.getElementById("taskType")?.addEventListener("change", (e) => {
        const code = e.target.value;
        renderTaskFieldsForCode(code);
        applyDefaultMarkerForCode(code);
        persistAll();
      });

      document.getElementById("taskMarkerCount")?.addEventListener("change", () => {
        const count = clamp(parseInt(document.getElementById("taskMarkerCount")?.value || "0", 10) || 0, 0, APP.maxMarkerButtons);
        const colors = [];
        document.querySelectorAll("#taskMarkerColors input[type='color']").forEach(inp => colors.push(inp.value));
        renderMarkerColorPickers(count, ensureMarkerColorsArray({ markerColors: colors }, count));
      });

      document.getElementById("btnAddTaskToBrief")?.addEventListener("click", addTaskToSelectedBriefing);
      document.getElementById("btnClearTaskForm")?.addEventListener("click", () => {
        const code = document.getElementById("taskType")?.value || "JDG";
        document.getElementById("taskTitle").value = "";
        renderTaskFieldsForCode(code);
        const def = defaultMarkerCountForTask(code);
        document.getElementById("taskMarkerCount").value = String(def);
        renderMarkerColorPickers(def, defaultMarkerColors(def));
        showSnackbar("Task-Form zurückgesetzt.");
      });

      // Use selected task from briefing list
      document.getElementById("btnUseSelectedTask")?.addEventListener("click", () => {
        const b = getSelectedBriefing();
        if (!b) { showSnackbar("Kein Briefing."); return; }
        const id = STATE.ui.selectedBriefTaskId || b.tasks?.[0]?.id;
        if (!id) { showSnackbar("Kein Task."); return; }
        // Free selection allowed if briefing is not active flight run; in flight the mode is enforced inside activateBriefingTask()
        activateBriefingTask(id, true);
      });

      document.getElementById("btnClearActiveTask")?.addEventListener("click", clearActiveTaskOverlay);
      document.getElementById("btnNextTask")?.addEventListener("click", nextTask);

      // Wind panel
      document.getElementById("btnAddWind")?.addEventListener("click", () => {
        const alt = safeFloat(document.getElementById("windAlt")?.value, null);
        const dir = safeFloat(document.getElementById("windDirFrom")?.value, null);
        const spd = safeFloat(document.getElementById("windSpd")?.value, null);
        if (alt == null || dir == null || spd == null) { showSnackbar("Wind: Werte fehlen."); return; }
        addWindLayer({ altM: alt, fromDeg: dir, speedKmh: spd, ts: now(), source: "manual" });
      });
      document.getElementById("btnClearWind")?.addEventListener("click", () => {
        STATE.wind.layers = [];
        persistAll();
        updateWindPanel();
        updateWindHud();
        updateNavToast();
        rebuildTrajectory();
        showSnackbar("Wind gelöscht.");
      });

      // Setup
      const tglSim = document.getElementById("tglSim");
      const knobSim = document.getElementById("tglSimKnob");
      if (tglSim && knobSim) setToggleUI(tglSim, knobSim, STATE.sim.enabled);
      tglSim?.addEventListener("change", (e) => {
        if (tglSim && knobSim) setToggleUI(tglSim, knobSim, e.target.checked);
        // keep it simple: simulation toggle removed here for brevity in briefing build
        showSnackbar("Simulation in dieser Version deaktiviert (Briefing-Fokus).");
        e.target.checked = false;
        if (tglSim && knobSim) setToggleUI(tglSim, knobSim, false);
      });

      document.getElementById("btnWakeLock")?.addEventListener("click", requestWakeLock);
      document.getElementById("btnResetUi")?.addEventListener("click", () => {
        STATE.ui.followGps = true;
        STATE.ui.windHudOpen = false;
        updateFollowToggleUi();
        updateWindHud();
        showSnackbar("UI zurückgesetzt.");
        persistAll();
      });

      document.getElementById("btnClearWaypoint")?.addEventListener("click", clearWaypoint);
      document.getElementById("kmlFile")?.addEventListener("change", (e) => importKmlFile(e.target.files?.[0]));

      // Archive
      document.getElementById("btnClearArchive")?.addEventListener("click", () => {
        STATE.flight.archive = [];
        persistAll();
        updateArchivePanel();
        showSnackbar("Archiv gelöscht.");
      });

      // WakeLock reacquire
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && STATE.ui.wakeLock) requestWakeLock();
      });

      // Start GPS
      initGPS();

      // If an active briefing exists, show badge
      updateBriefingHeaderBadge();
      renderBriefTasksList();
      renderMarkerStrip();
    };
  </script>
</body>
</html>
